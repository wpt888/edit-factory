---
phase: 13-tts-based-subtitles
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/services/tts_subtitle_generator.py
autonomous: true

must_haves:
  truths:
    - "Character-level timestamps are grouped into words by splitting on spaces and punctuation"
    - "Words are grouped into phrase-level subtitle entries with natural timing (max ~6-8 words or ~40 chars per entry)"
    - "Generated SRT content has correct SRT format with sequential numbering, HH:MM:SS,mmm timing, and text lines"
    - "Empty or malformed timestamp data returns empty string gracefully without raising exceptions"
  artifacts:
    - path: "app/services/tts_subtitle_generator.py"
      provides: "TTS timestamp to SRT conversion service"
      contains: "def generate_srt_from_timestamps"
  key_links:
    - from: "app/services/tts_subtitle_generator.py"
      to: "ElevenLabs alignment dict"
      via: "Input parameter matching tts_timestamps JSONB schema"
      pattern: "characters.*character_start_times_seconds.*character_end_times_seconds"
---

<objective>
Create a service that converts ElevenLabs character-level timestamps into properly formatted SRT subtitle content.

Purpose: Enables subtitle generation directly from TTS timing data, eliminating the need for Whisper ASR and providing perfect sync with voiceover audio. This is the core algorithm for Phase 13.

Output: `app/services/tts_subtitle_generator.py` with `generate_srt_from_timestamps()` function
</objective>

<execution_context>
@/home/ukfdb/.claude/get-shit-done/workflows/execute-plan.md
@/home/ukfdb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 12 established the timestamp format
@.planning/phases/12-elevenlabs-tts-upgrade/12-02-SUMMARY.md
@app/services/tts/elevenlabs.py
@app/services/subtitle_styler.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TTS subtitle generator service</name>
  <files>app/services/tts_subtitle_generator.py</files>
  <action>
Create `app/services/tts_subtitle_generator.py` with a `generate_srt_from_timestamps()` function.

**Input:** ElevenLabs alignment dict with structure:
```python
{
    "characters": ["H", "e", "l", "l", "o", " ", "w", "o", "r", "l", "d"],
    "character_start_times_seconds": [0.0, 0.05, 0.09, 0.12, 0.15, 0.20, 0.25, 0.30, 0.34, 0.38, 0.42],
    "character_end_times_seconds": [0.05, 0.09, 0.12, 0.15, 0.20, 0.25, 0.30, 0.34, 0.38, 0.42, 0.46]
}
```

**Output:** SRT-formatted string, e.g.:
```
1
00:00:00,000 --> 00:00:00,460
Hello world
```

**Algorithm (3-step grouping):**

1. **Characters to words:** Iterate through characters array. Accumulate characters into current word. When a space character is encountered, finalize the current word with start_time = first char's start, end_time = last char's end. Strip whitespace from word text. Handle punctuation attached to words (e.g., "Hello," stays as one word).

2. **Words to phrases:** Group words into subtitle entries. A new phrase boundary is created when:
   - Accumulated text exceeds 40 characters, OR
   - Accumulated word count exceeds 7 words, OR
   - A sentence-ending punctuation (`.`, `!`, `?`) is encountered at word end

   Each phrase gets: start_time from first word, end_time from last word.

3. **Phrases to SRT:** Format each phrase as SRT entry:
   ```
   {index}
   {start_time} --> {end_time}
   {text}
   ```
   Time format: `HH:MM:SS,mmm` (SRT standard with comma separator).

**Helper function:** `_seconds_to_srt_time(seconds: float) -> str` that converts float seconds to `HH:MM:SS,mmm` format.

**Edge cases to handle:**
- Empty or None timestamps dict -> return empty string
- Missing keys in dict -> return empty string with warning log
- Single character input -> valid single-entry SRT
- Text with no spaces (single long word) -> single SRT entry
- Consecutive spaces -> skip, don't create empty words

**Logging:** Use `logging.getLogger(__name__)` for info/warning messages.

**Do NOT** import or depend on the `srt` library - generate SRT format manually (it's a trivial format, and avoids adding a dependency to this service). The `srt` library is used in subtitle_styler.py for parsing, but this service only generates.

**Function signature:**
```python
def generate_srt_from_timestamps(
    timestamps: dict,
    max_chars_per_phrase: int = 40,
    max_words_per_phrase: int = 7
) -> str:
```
  </action>
  <verify>
Run: `python -c "from app.services.tts_subtitle_generator import generate_srt_from_timestamps; print(generate_srt_from_timestamps({'characters': list('Hello world'), 'character_start_times_seconds': [0.0,0.05,0.09,0.12,0.15,0.20,0.25,0.30,0.34,0.38,0.42], 'character_end_times_seconds': [0.05,0.09,0.12,0.15,0.20,0.25,0.30,0.34,0.38,0.42,0.46]}))"`

Should output a valid SRT entry with correct timing. Also test empty input: `generate_srt_from_timestamps({})` should return empty string. Also test `generate_srt_from_timestamps(None)` should return empty string.
  </verify>
  <done>
Function exists, imports cleanly, converts character timestamps to valid SRT format. Empty/None input returns empty string without exceptions. Multi-word text produces correctly timed SRT entries. Phrase boundaries respect max_chars and max_words limits.
  </done>
</task>

</tasks>

<verification>
1. Module imports without errors: `python -c "from app.services.tts_subtitle_generator import generate_srt_from_timestamps"`
2. Basic conversion works: generates valid SRT from sample timestamp data
3. Edge cases handled: None input, empty dict, single word, long text
4. SRT timing format is correct: `HH:MM:SS,mmm` with comma separator (not period)
</verification>

<success_criteria>
- `generate_srt_from_timestamps()` converts ElevenLabs alignment dict to valid SRT string
- Character-to-word grouping correctly handles spaces and punctuation
- Word-to-phrase grouping respects configurable limits (40 chars, 7 words)
- Sentence-ending punctuation creates natural phrase boundaries
- Edge cases (empty, None, single word) handled gracefully
</success_criteria>

<output>
After completion, create `.planning/phases/13-tts-based-subtitles/13-01-SUMMARY.md`
</output>
