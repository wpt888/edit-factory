---
phase: 04-tts-provider-selection
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - app/services/tts/coqui.py
  - app/services/tts/factory.py
  - requirements.txt
autonomous: true

must_haves:
  truths:
    - "Coqui XTTS generates audio via TTSService interface"
    - "Voice cloning creates usable voice from 6-second sample"
    - "Model loads lazily on first use (not at import)"
    - "GPU availability checked and CPU fallback logged"
  artifacts:
    - path: "app/services/tts/coqui.py"
      provides: "Coqui XTTS TTSService implementation with voice cloning"
      exports: ["CoquiTTSService"]
  key_links:
    - from: "app/services/tts/coqui.py"
      to: "app/services/tts/base.py"
      via: "extends TTSService"
      pattern: "class CoquiTTSService.*TTSService"
    - from: "app/services/tts/coqui.py"
      to: "TTS.api"
      via: "imports Coqui TTS library"
      pattern: "from TTS.api import TTS"
---

<objective>
Implement Coqui XTTS v2 service with voice cloning support.

Purpose: Add free local TTS engine with voice cloning capability. Enables TTS-03 (Coqui integration) and TTS-06 (voice cloning workflow).

Output: CoquiTTSService class with voice cloning, lazy model loading, GPU/CPU fallback.
</objective>

<execution_context>
@/home/ukfdb/.claude/get-shit-done/workflows/execute-plan.md
@/home/ukfdb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-tts-provider-selection/04-RESEARCH.md

# Required context from 04-01
@app/services/tts/base.py
@app/services/tts/factory.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Coqui TTS dependencies</name>
  <files>requirements.txt</files>
  <action>
Add Coqui TTS dependencies to requirements.txt:

```
# TTS - Coqui XTTS (voice cloning, 17 languages)
TTS>=0.22.0
librosa>=0.10.0
soundfile>=0.12.0
pydub>=0.25.0
```

Note: PyTorch is a transitive dependency of TTS. Users with NVIDIA GPU should install PyTorch separately with CUDA support:
```bash
pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu121
```

Add comment explaining CUDA installation for GPU support.
  </action>
  <verify>
```bash
grep -E "^TTS|^librosa|^soundfile|^pydub" "/mnt/c/OBSID SRL/n8n/edit_factory/requirements.txt"
```
Should show all four dependencies.
  </verify>
  <done>
Coqui TTS and audio processing dependencies added to requirements.txt.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create CoquiTTSService</name>
  <files>app/services/tts/coqui.py</files>
  <action>
Create CoquiTTSService implementing TTSService interface with voice cloning:

1. Import from base.py: TTSService, TTSVoice, TTSResult
2. Import torch for CUDA detection, asyncio for async execution
3. Import TTS from TTS.api (Coqui library)

4. Class CoquiTTSService(TTSService):
   - Constructor: output_dir, model_name="tts_models/multilingual/multi-dataset/xtts_v2", use_gpu=True
   - Instance variables: _model (Optional[TTS]), _cloned_voices (Dict[str, Path])
   - Class-level model cache: _model_cache (Dict), _model_lock (asyncio.Lock)

5. Implement abstract properties:
   - provider_name -> "coqui"
   - cost_per_1k_chars -> 0.0 (free)

6. Lazy model loading with singleton pattern:
   - async _get_model() method
   - Use asyncio.Lock to prevent concurrent model loading
   - Cache model in class-level _model_cache by model_name
   - Run model loading in executor (TTS() is synchronous)
   - Log GPU vs CPU mode clearly

7. GPU fallback logic:
   - Check torch.cuda.is_available() in constructor
   - If use_gpu=True but CUDA unavailable, log warning and set use_gpu=False
   - Log GPU device name if available

8. Implement abstract methods:
   - list_voices(): Return list of cloned voices (XTTS has no preset voices)
   - generate_audio(text, voice_id, output_path, language="en"):
     - Validate voice_id exists in _cloned_voices
     - Call model.tts_to_file() in executor
     - Calculate duration using librosa
     - Return TTSResult
   - supports_voice_cloning() -> True

9. Implement clone_voice(sample_audio_path, voice_name):
   - Validate sample exists
   - Validate duration >= 6 seconds using librosa
   - Generate unique voice_id: {name}_{uuid[:8]}
   - Store sample_audio_path in _cloned_voices dict
   - Return voice_id

10. CRITICAL: Do NOT import TTS at module level. Use lazy import inside methods to avoid loading PyTorch on startup.
  </action>
  <verify>
```bash
cd "/mnt/c/OBSID SRL/n8n/edit_factory" && python -c "
# Verify class structure without loading heavy dependencies
import ast
with open('app/services/tts/coqui.py') as f:
    tree = ast.parse(f.read())
classes = [n.name for n in ast.walk(tree) if isinstance(n, ast.ClassDef)]
print(f'Classes: {classes}')
assert 'CoquiTTSService' in classes, 'CoquiTTSService not found'
print('CoquiTTSService structure OK')
"
```
  </verify>
  <done>
CoquiTTSService exists with voice cloning support, lazy model loading, GPU/CPU fallback.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update factory for Coqui provider</name>
  <files>app/services/tts/factory.py</files>
  <action>
Update factory.py to support Coqui provider:

1. Add lazy import for CoquiTTSService inside get_tts_service() to avoid loading PyTorch at import time:
```python
elif provider == "coqui":
    from app.services.tts.coqui import CoquiTTSService
    return CoquiTTSService(
        output_dir=output_dir,
        model_name="tts_models/multilingual/multi-dataset/xtts_v2",
        use_gpu=True
    )
```

2. Keep other providers unchanged.
  </action>
  <verify>
```bash
cd "/mnt/c/OBSID SRL/n8n/edit_factory" && python -c "
# Verify factory structure without loading Coqui
import ast
with open('app/services/tts/factory.py') as f:
    content = f.read()
assert 'coqui' in content.lower()
assert 'CoquiTTSService' in content
print('Factory includes Coqui provider')
"
```
  </verify>
  <done>
Factory returns CoquiTTSService for "coqui" provider with lazy import.
  </done>
</task>

</tasks>

<verification>
1. requirements.txt includes TTS, librosa, soundfile, pydub
2. CoquiTTSService class exists and extends TTSService
3. CoquiTTSService.supports_voice_cloning() returns True
4. Factory includes "coqui" case with lazy import
5. No PyTorch loading on factory import (lazy import pattern)
</verification>

<success_criteria>
- CoquiTTSService implements full TTSService interface
- Voice cloning via clone_voice() method works (stores path, validates duration)
- Lazy model loading prevents startup delay
- GPU/CPU fallback works with clear logging
- Factory returns CoquiTTSService for "coqui" provider
</success_criteria>

<output>
After completion, create `.planning/phases/04-tts-provider-selection/04-03-SUMMARY.md`
</output>
