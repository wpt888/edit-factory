---
phase: 25-rate-limiting-and-security
plan: "02"
type: execute
wave: 1
depends_on: []
files_modified:
  - requirements.txt
  - app/services/elevenlabs_tts.py
  - app/services/tts/elevenlabs.py
  - app/services/gemini_analyzer.py
  - app/api/segments_routes.py
  - app/api/library_routes.py
  - app/services/srt_validator.py
autonomous: true
requirements:
  - SEC-02
  - SEC-03
  - STAB-06

must_haves:
  truths:
    - "SRT subtitle text stored in the database has HTML tags stripped to prevent script injection"
    - "Stream endpoints return Cache-Control headers appropriate for media content"
    - "ElevenLabs API calls retry automatically on transient HTTP failures (429, 500, 502, 503, 504)"
    - "Gemini API calls retry automatically on transient failures with exponential backoff"
  artifacts:
    - path: "requirements.txt"
      provides: "tenacity dependency"
      contains: "tenacity"
    - path: "app/services/elevenlabs_tts.py"
      provides: "Retry-decorated ElevenLabs API calls"
      contains: "tenacity"
    - path: "app/services/tts/elevenlabs.py"
      provides: "Retry-decorated ElevenLabs API calls (new service)"
      contains: "tenacity"
    - path: "app/services/gemini_analyzer.py"
      provides: "Retry-decorated Gemini API calls"
      contains: "tenacity"
    - path: "app/services/srt_validator.py"
      provides: "HTML tag stripping utility for SRT content"
      contains: "sanitize_srt_text"
    - path: "app/api/segments_routes.py"
      provides: "Cache-Control headers on stream endpoints"
      contains: "Cache-Control"
    - path: "app/api/library_routes.py"
      provides: "SRT sanitization on content storage and Cache-Control on file responses"
      contains: "sanitize_srt_text"
  key_links:
    - from: "app/services/elevenlabs_tts.py"
      to: "tenacity"
      via: "retry decorator on HTTP call"
      pattern: "@retry"
    - from: "app/services/gemini_analyzer.py"
      to: "tenacity"
      via: "retry decorator on analyze_batch"
      pattern: "@retry"
    - from: "app/services/srt_validator.py"
      to: "app/api/library_routes.py"
      via: "sanitize_srt_text import"
      pattern: "from app\\.services\\.srt_validator import sanitize_srt_text"
---

<objective>
Add HTML sanitization for SRT subtitle content, Cache-Control headers on media streaming endpoints, and tenacity retry logic for ElevenLabs and Gemini external API calls.

Purpose: Prevent XSS via user-supplied SRT content (SEC-02), set appropriate caching for media streams (SEC-03), and make external API calls resilient to transient failures (STAB-06).
Output: SRT text sanitized before storage, Cache-Control headers on all FileResponse stream endpoints, tenacity retry decorators on ElevenLabs and Gemini HTTP calls.
</objective>

<execution_context>
@/home/ukfdb/.claude/get-shit-done/workflows/execute-plan.md
@/home/ukfdb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-backend-stability/24-02-SUMMARY.md
@app/services/elevenlabs_tts.py
@app/services/tts/elevenlabs.py
@app/services/gemini_analyzer.py
@app/services/srt_validator.py
@app/api/segments_routes.py
@app/api/library_routes.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: SRT content sanitization and Cache-Control headers on stream endpoints</name>
  <files>app/services/srt_validator.py, app/api/library_routes.py, app/api/segments_routes.py</files>
  <action>
1. In app/services/srt_validator.py, add a sanitization helper at module level (near top, after imports):
   ```python
   import re

   def sanitize_srt_text(srt_content: str) -> str:
       """Strip HTML/script tags from SRT content to prevent XSS.

       Preserves SRT structure (timestamps, sequence numbers, blank lines)
       but removes any HTML tags from subtitle text lines.
       """
       if not srt_content:
           return srt_content
       # Remove HTML tags (including <script>...</script> with content)
       cleaned = re.sub(r'<script[^>]*>.*?</script>', '', srt_content, flags=re.DOTALL | re.IGNORECASE)
       # Remove remaining HTML tags but preserve SRT arrow (-->)
       cleaned = re.sub(r'<[^>]+>', '', cleaned)
       return cleaned
   ```
   Add the `import re` at the top of the file if not already present.

2. In app/api/library_routes.py, sanitize SRT content before it's stored in the database:
   - Import: `from app.services.srt_validator import sanitize_srt_text`
   - In the `update_clip_content` endpoint (the PUT handler for clip content around line 1730-1745), where `content.srt_content` is written to `content_data`, add sanitization:
     ```python
     if content.srt_content is not None:
         content_data["srt_content"] = sanitize_srt_text(content.srt_content)
     ```
     (Replace the existing `content_data["srt_content"] = content.srt_content` with the sanitized version.)
   - Also in the `_render_final_clip_task` function where SRT content is written to a file (~line 2168-2171), sanitize before writing:
     ```python
     srt_text = sanitize_srt_text(content_data["srt_content"])
     f.write(srt_text)
     ```

3. Add Cache-Control headers to stream/file endpoints:

   In app/api/segments_routes.py:
   - In `stream_source_video` (line ~456), modify the FileResponse to include headers:
     ```python
     return FileResponse(
         path=str(video_path),
         media_type=media_type,
         filename=video_path.name,
         headers={"Cache-Control": "public, max-age=3600"}
     )
     ```
   - In `stream_segment` (line ~1079), add headers to both FileResponse calls:
     ```python
     return FileResponse(path=str(path), media_type="video/mp4", headers={"Cache-Control": "public, max-age=3600"})
     ```

   In app/api/library_routes.py:
   - In `serve_file` (~line 289), add headers to the FileResponse:
     ```python
     return FileResponse(
         path=str(resolved_path),
         media_type=media_type or "application/octet-stream",
         filename=resolved_path.name if download else None,
         headers={"Cache-Control": "public, max-age=3600"}
     )
     ```
   - In `download_clip_video` (~line 349), add Cache-Control header to the FileResponse:
     ```python
     headers={"Cache-Control": "public, max-age=3600"}
     ```

   Use `public, max-age=3600` (1 hour) for media files. This allows browser caching without excessive staleness for video content that changes infrequently.
  </action>
  <verify>
Run `cd /mnt/c/OBSID\ SRL/n8n/edit_factory && python -c "from app.services.srt_validator import sanitize_srt_text; print(sanitize_srt_text('<script>alert(1)</script>Hello'))"` — should print "Hello".
Run `cd /mnt/c/OBSID\ SRL/n8n/edit_factory && python -c "from app.services.srt_validator import sanitize_srt_text; print(sanitize_srt_text('1\n00:00:01,000 --> 00:00:02,000\nHello world\n'))"` — should preserve SRT structure with arrow intact.
Grep for `Cache-Control` in `app/api/segments_routes.py` and `app/api/library_routes.py` — should find header additions.
  </verify>
  <done>SRT content is sanitized (HTML tags stripped) before database storage and before file writing. Stream/file endpoints return Cache-Control: public, max-age=3600 headers. SRT arrows (-->) preserved by the sanitizer.</done>
</task>

<task type="auto">
  <name>Task 2: Add tenacity retry logic to ElevenLabs and Gemini API calls</name>
  <files>requirements.txt, app/services/elevenlabs_tts.py, app/services/tts/elevenlabs.py, app/services/gemini_analyzer.py</files>
  <action>
1. Add `tenacity>=8.2.0` to requirements.txt in the "Utilities" section (after pydantic-settings).

2. In app/services/elevenlabs_tts.py (legacy ElevenLabs service):
   - Import: `from tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception_type`
   - Import: `import httpx` (already imported)
   - Create a custom retry condition near the top of the class or as a module-level helper:
     ```python
     def _is_transient_error(exc: Exception) -> bool:
         """Check if an HTTP error is transient and worth retrying."""
         if isinstance(exc, httpx.HTTPStatusError):
             return exc.response.status_code in (429, 500, 502, 503, 504)
         if isinstance(exc, (httpx.ConnectError, httpx.ReadTimeout, httpx.WriteTimeout)):
             return True
         return False
     ```
   - In the `generate_audio` method (~line 55), wrap the HTTP call logic. Instead of decorating the entire method (which has cache logic), create an inner helper decorated with retry:
     ```python
     @retry(
         stop=stop_after_attempt(3),
         wait=wait_exponential(multiplier=1, min=2, max=30),
         retry=retry_if_exception_type((httpx.ConnectError, httpx.ReadTimeout, httpx.WriteTimeout)),
         before_sleep=lambda retry_state: logger.warning(
             f"ElevenLabs API retry {retry_state.attempt_number}/3: {retry_state.outcome.exception()}"
         ),
         reraise=True
     )
     async def _call_elevenlabs_api(url, headers, data):
         async with httpx.AsyncClient(timeout=120.0) as client:
             response = await client.post(url, headers=headers, json=data)
             if response.status_code in (429, 500, 502, 503, 504):
                 raise httpx.HTTPStatusError(
                     f"Transient error {response.status_code}",
                     request=response.request,
                     response=response
                 )
             return response
     ```
     Place this function at module level (outside the class). Then in `generate_audio`, replace the `async with httpx.AsyncClient...` block with `response = await _call_elevenlabs_api(url, headers, data)`. Add `httpx.HTTPStatusError` to the retry_if_exception_type tuple.

3. In app/services/tts/elevenlabs.py (new ElevenLabs service):
   - Import: `from tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception_type`
   - Apply the same retry pattern to the `generate_audio` method (~line 206) and `generate_audio_with_timestamps` method (~line 322). Use the same `_call_elevenlabs_api` pattern — create a module-level retry-decorated async helper.
   - The helper takes url, headers, data, timeout and returns the httpx response. Both generate methods call this helper instead of raw httpx.

4. In app/services/gemini_analyzer.py:
   - Import: `from tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception_type`
   - The Gemini SDK `self.client.models.generate_content()` call (~line 197) can throw google.api_core.exceptions or network errors. Wrap the API call with tenacity retry:
     ```python
     @retry(
         stop=stop_after_attempt(3),
         wait=wait_exponential(multiplier=1, min=2, max=30),
         reraise=True,
         before_sleep=lambda retry_state: logger.warning(
             f"Gemini API retry {retry_state.attempt_number}/3: {retry_state.outcome.exception()}"
         )
     )
     def _call_gemini_api(self, model, contents):
         return self.client.models.generate_content(model=model, contents=contents)
     ```
     Add this as a method on the GeminiVideoAnalyzer class. In `analyze_batch` (~line 197), replace `response = self.client.models.generate_content(...)` with `response = self._call_gemini_api(self.model_name, contents)`.

   Note: The Gemini SDK is synchronous (not async), so use a regular function with @retry, not an async one.

All retry patterns use: max 3 attempts, exponential backoff starting at 2s, max 30s between retries. Transient errors retried: 429 (rate limit), 500, 502, 503, 504 (server errors), and connection/timeout errors.
  </action>
  <verify>
Run `cd /mnt/c/OBSID\ SRL/n8n/edit_factory && python -c "import tenacity; print('tenacity import OK')"` to verify tenacity is installed.
Run `cd /mnt/c/OBSID\ SRL/n8n/edit_factory && python -c "from app.services.elevenlabs_tts import ElevenLabsTTS; print('legacy elevenlabs OK')"` to verify no import errors.
Run `cd /mnt/c/OBSID\ SRL/n8n/edit_factory && python -c "from app.services.tts.elevenlabs import ElevenLabsTTSService; print('new elevenlabs OK')"` to verify no import errors.
Run `cd /mnt/c/OBSID\ SRL/n8n/edit_factory && python -c "from app.services.gemini_analyzer import GeminiVideoAnalyzer; print('gemini OK')"` — note this may fail if GEMINI_API_KEY is not set; import check is sufficient.
Grep for `@retry` in `app/services/elevenlabs_tts.py`, `app/services/tts/elevenlabs.py`, `app/services/gemini_analyzer.py` — should find retry decorators.
  </verify>
  <done>All ElevenLabs HTTP calls (legacy and new service) and Gemini API calls are wrapped with tenacity retry — 3 attempts, exponential backoff 2-30s, retries on transient HTTP errors (429, 500-504) and connection/timeout failures.</done>
</task>

</tasks>

<verification>
1. `grep -rn "sanitize_srt_text" app/` — found in srt_validator.py (definition) and library_routes.py (usage)
2. `grep -rn "Cache-Control" app/api/segments_routes.py app/api/library_routes.py` — found in stream/file endpoints
3. `grep -rn "@retry" app/services/elevenlabs_tts.py app/services/tts/elevenlabs.py app/services/gemini_analyzer.py` — found in all three
4. `grep -rn "tenacity" requirements.txt` — tenacity listed as dependency
5. `python -c "from app.services.srt_validator import sanitize_srt_text; assert sanitize_srt_text('<b>bold</b>') == 'bold'"` — HTML stripped
6. `python -c "from app.services.srt_validator import sanitize_srt_text; assert '-->' in sanitize_srt_text('00:00:01,000 --> 00:00:02,000')"` — SRT arrows preserved
</verification>

<success_criteria>
- SRT content sanitized (HTML tags stripped) before database storage
- SRT arrows (-->) preserved by sanitizer
- Stream endpoints (source-videos/{id}/stream, {segment_id}/stream, serve_file, download_clip_video) include Cache-Control: public, max-age=3600
- ElevenLabs API calls (both legacy and new service) retry up to 3 times on transient errors
- Gemini API calls retry up to 3 times on transient errors
- All retries use exponential backoff (2s, 4s, 8s... up to 30s max)
</success_criteria>

<output>
After completion, create `.planning/phases/25-rate-limiting-and-security/25-02-SUMMARY.md`
</output>
