---
phase: 25-rate-limiting-and-security
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - requirements.txt
  - app/main.py
  - app/api/validators.py
  - app/api/tts_routes.py
  - app/api/tts_library_routes.py
  - app/api/library_routes.py
autonomous: true
requirements:
  - SEC-01
  - SEC-04

must_haves:
  truths:
    - "Exceeding the request rate limit returns HTTP 429 Too Many Requests"
    - "TTS text exceeding 5000 characters is rejected with 400 at the endpoint before any background job starts"
    - "Rate limit applies per-client based on IP address"
  artifacts:
    - path: "requirements.txt"
      provides: "slowapi dependency"
      contains: "slowapi"
    - path: "app/main.py"
      provides: "Rate limiter middleware registration"
      contains: "SlowAPIMiddleware"
    - path: "app/api/validators.py"
      provides: "Shared MAX_TTS_CHARS constant and validate_tts_text_length helper"
      contains: "MAX_TTS_CHARS"
    - path: "app/api/tts_routes.py"
      provides: "TTS text length validation before background job dispatch"
      contains: "validate_tts_text_length"
    - path: "app/api/tts_library_routes.py"
      provides: "TTS asset text length validation"
      contains: "MAX_TTS_CHARS"
  key_links:
    - from: "app/main.py"
      to: "slowapi"
      via: "SlowAPIMiddleware added to app"
      pattern: "app\\.state\\.limiter"
    - from: "app/api/validators.py"
      to: "app/api/tts_routes.py"
      via: "MAX_TTS_CHARS import"
      pattern: "from app\\.api\\.validators import"
---

<objective>
Add slowapi rate limiting middleware to the FastAPI application and centralize TTS text length validation so every TTS endpoint enforces the 5000-character limit before dispatching a background job.

Purpose: Prevent abuse via excessive requests (SEC-01) and reject oversized TTS text early at the HTTP layer (SEC-04) instead of failing inside background tasks.
Output: slowapi middleware active on all routes, centralized MAX_TTS_CHARS constant in validators.py, all TTS endpoints validate text length.
</objective>

<execution_context>
@/home/ukfdb/.claude/get-shit-done/workflows/execute-plan.md
@/home/ukfdb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-backend-stability/24-02-SUMMARY.md
@app/main.py
@app/api/validators.py
@app/api/tts_routes.py
@app/api/tts_library_routes.py
@app/api/routes.py
@requirements.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add slowapi rate limiting middleware</name>
  <files>requirements.txt, app/main.py</files>
  <action>
1. Add `slowapi>=0.1.9` to requirements.txt in the "Web Framework" section (after python-multipart).

2. In app/main.py, add rate limiting:
   - Import: `from slowapi import Limiter, _rate_limit_exceeded_handler` and `from slowapi.util import get_remote_address` and `from slowapi.errors import RateLimitExceeded` and `from slowapi.middleware import SlowAPIMiddleware`
   - Create limiter instance BEFORE the app is created: `limiter = Limiter(key_func=get_remote_address, default_limits=["60/minute"])` — 60 requests/minute per IP as default.
   - After `app = FastAPI(...)`, add: `app.state.limiter = limiter` and `app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)` and `app.add_middleware(SlowAPIMiddleware)`
   - Place the SlowAPIMiddleware BEFORE the CORSMiddleware registration (FastAPI processes middleware in reverse order, so SlowAPI should be added first to run after CORS).

The default 60/minute limit applies globally. Individual routes can override with `@limiter.limit("10/minute")` decorator if needed later. The `_rate_limit_exceeded_handler` returns a 429 JSON response automatically.

Do NOT add per-route decorators — the default_limits on the Limiter instance applies to all routes automatically.
  </action>
  <verify>
Run `cd /mnt/c/OBSID\ SRL/n8n/edit_factory && python -c "from slowapi import Limiter; print('slowapi import OK')"` to verify the package is importable.
Run `cd /mnt/c/OBSID\ SRL/n8n/edit_factory && python -c "from app.main import app; print('app imports OK')"` to verify main.py loads without errors.
  </verify>
  <done>slowapi middleware is registered on the FastAPI app with a 60/minute default rate limit per IP. Exceeding the limit returns 429 Too Many Requests.</done>
</task>

<task type="auto">
  <name>Task 2: Centralize TTS text length validation and enforce in all TTS endpoints</name>
  <files>app/api/validators.py, app/api/tts_routes.py, app/api/tts_library_routes.py, app/api/routes.py, app/api/library_routes.py</files>
  <action>
1. In app/api/validators.py (already exists from Phase 24-02 with validate_upload_size):
   - Add constant: `MAX_TTS_CHARS = 5000`
   - Add helper function:
     ```python
     def validate_tts_text_length(text: str, field_name: str = "text") -> str:
         """Validate TTS text is non-empty and within character limit. Returns stripped text."""
         stripped = text.strip() if text else ""
         if not stripped:
             raise HTTPException(status_code=400, detail=f"{field_name} cannot be empty")
         if len(stripped) > MAX_TTS_CHARS:
             raise HTTPException(
                 status_code=400,
                 detail=f"Text too long: {len(stripped)} characters (maximum {MAX_TTS_CHARS})"
             )
         return stripped
     ```
   - Import HTTPException from fastapi at the top of the file.

2. In app/api/tts_routes.py (the `/tts/generate` endpoint around line 249):
   - Import: `from app.api.validators import validate_tts_text_length`
   - After the quota check and before the job creation, add: `text = validate_tts_text_length(text)` — this validates and strips. Currently this endpoint has NO length check at all.

3. In app/api/tts_library_routes.py:
   - Import: `from app.api.validators import MAX_TTS_CHARS`
   - In the `create_tts_asset` endpoint (POST /), after the `if not request.tts_text.strip()` check (~line 198), add a length check:
     ```python
     if len(request.tts_text.strip()) > MAX_TTS_CHARS:
         raise HTTPException(status_code=400, detail=f"Text too long: {len(request.tts_text.strip())} characters (maximum {MAX_TTS_CHARS})")
     ```
   - In the `update_tts_asset` endpoint (PUT /{asset_id}), after the `if not request.tts_text.strip()` check (~line 271), add the same length check.

4. In app/api/routes.py:
   - Import: `from app.api.validators import MAX_TTS_CHARS` (if not already imported)
   - Replace the three inline `MAX_TTS_CHARS = 5000` definitions (lines ~1047, ~1222, ~1288) with the imported constant. Remove the local variable definitions but keep the if-checks that use them.

5. In app/api/library_routes.py — check if the render endpoint passes tts_text to background task without length validation. The `generate_raw_clips` endpoint at ~line 790 accepts `tts_text` parameter. If there is no length validation before dispatching background task, add:
   ```python
   if request.tts_text and len(request.tts_text.strip()) > MAX_TTS_CHARS:
       raise HTTPException(status_code=400, detail=f"TTS text too long: {len(request.tts_text.strip())} characters (maximum {MAX_TTS_CHARS})")
   ```
   Import `MAX_TTS_CHARS` from `app.api.validators`.
  </action>
  <verify>
Run `cd /mnt/c/OBSID\ SRL/n8n/edit_factory && python -c "from app.api.validators import MAX_TTS_CHARS, validate_tts_text_length; print(f'MAX_TTS_CHARS={MAX_TTS_CHARS}')"` to verify the constant and function are importable.
Run `cd /mnt/c/OBSID\ SRL/n8n/edit_factory && python -c "from app.api.tts_routes import router; print('tts_routes OK')"` to verify no import errors.
Run `cd /mnt/c/OBSID\ SRL/n8n/edit_factory && python -c "from app.api.tts_library_routes import router; print('tts_library_routes OK')"` to verify no import errors.
Grep for `MAX_TTS_CHARS = 5000` — should only appear in validators.py (not duplicated in routes.py).
  </verify>
  <done>MAX_TTS_CHARS=5000 is defined once in validators.py. All TTS endpoints (routes.py /tts/generate, routes.py /tts/generate-with-video, tts_routes.py /generate, tts_library_routes.py POST and PUT, library_routes.py generate) validate text length at the endpoint level before dispatching background jobs.</done>
</task>

</tasks>

<verification>
1. `grep -rn "MAX_TTS_CHARS = 5000" app/` — only appears in app/api/validators.py
2. `grep -rn "slowapi\|SlowAPIMiddleware" app/main.py` — shows middleware registration
3. `grep -rn "validate_tts_text_length\|MAX_TTS_CHARS" app/api/tts_routes.py` — shows import and usage
4. `python -c "from app.main import app; print('OK')"` — app loads without errors
</verification>

<success_criteria>
- slowapi rate limiting active with 60/minute default per IP
- All TTS endpoints validate text length <= 5000 chars before background job dispatch
- MAX_TTS_CHARS defined exactly once in validators.py
- No inline MAX_TTS_CHARS definitions remain in routes.py
</success_criteria>

<output>
After completion, create `.planning/phases/25-rate-limiting-and-security/25-01-SUMMARY.md`
</output>
