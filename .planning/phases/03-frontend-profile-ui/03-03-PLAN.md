---
phase: 03-frontend-profile-ui
plan: 03
type: execute
wave: 3
depends_on: ["03-01", "03-02"]
files_modified:
  - frontend/src/app/layout.tsx
  - frontend/src/components/navbar.tsx
  - frontend/src/app/librarie/page.tsx
autonomous: false

must_haves:
  truths:
    - "ProfileProvider wraps entire app in root layout"
    - "ProfileSwitcher visible in navbar when not loading"
    - "Active profile name displayed in navbar badge"
    - "Library page refetches data when profile changes"
    - "Library page waits for profile context before fetching"
  artifacts:
    - path: "frontend/src/app/layout.tsx"
      provides: "Root layout with ProfileProvider wrapper"
      contains: "ProfileProvider"
    - path: "frontend/src/components/navbar.tsx"
      provides: "Navbar with ProfileSwitcher and profile badge"
      contains: "ProfileSwitcher"
    - path: "frontend/src/app/librarie/page.tsx"
      provides: "Library page with profile-aware data fetching"
      contains: "useProfile"
  key_links:
    - from: "frontend/src/app/layout.tsx"
      to: "ProfileProvider"
      via: "wrapping children with context provider"
      pattern: "<ProfileProvider>"
    - from: "frontend/src/components/navbar.tsx"
      to: "profile-context"
      via: "useProfile for displaying current profile"
      pattern: "useProfile"
    - from: "frontend/src/components/navbar.tsx"
      to: "ProfileSwitcher"
      via: "rendering ProfileSwitcher component"
      pattern: "<ProfileSwitcher"
    - from: "frontend/src/app/librarie/page.tsx"
      to: "profile-context"
      via: "useProfile for currentProfile dependency"
      pattern: "currentProfile"
---

<objective>
Integrate profile management throughout the app: wrap with provider, add switcher to navbar, and make library page profile-aware.

Purpose: This plan wires everything together so users can actually use the profile system. The layout provides context to all pages, the navbar shows the switcher, and the library page responds to profile changes.

Output: Integrated profile system visible and functional throughout the application.
</objective>

<execution_context>
@/home/ukfdb/.claude/get-shit-done/workflows/execute-plan.md
@/home/ukfdb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-frontend-profile-ui/03-RESEARCH.md
@.planning/phases/03-frontend-profile-ui/03-01-SUMMARY.md
@.planning/phases/03-frontend-profile-ui/03-02-SUMMARY.md

# Files to modify
@frontend/src/app/layout.tsx
@frontend/src/components/navbar.tsx
@frontend/src/app/librarie/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wrap app with ProfileProvider in layout.tsx</name>
  <files>frontend/src/app/layout.tsx</files>
  <action>
Modify `frontend/src/app/layout.tsx` to wrap the app with ProfileProvider:

1. Add import at top:
```typescript
import { ProfileProvider } from "@/contexts/profile-context";
```

2. Wrap the body contents with ProfileProvider:
   - ProfileProvider wraps NavBar and children (but NOT Toaster - toasts work outside context)
   - Keep existing structure: NavBar, children, Toaster

Layout structure should be:
```tsx
<body className={...}>
  <ProfileProvider>
    <NavBar />
    {children}
  </ProfileProvider>
  <Toaster ... />
</body>
```

Note: ProfileProvider is a client component ("use client"), so this works fine in the root layout. The root layout itself remains a server component, but can render client component children.

AVOID: Wrapping Toaster in ProfileProvider (unnecessary, may cause issues). AVOID: Removing any existing class names or font variables.
  </action>
  <verify>
TypeScript compilation passes: `cd frontend && npx tsc --noEmit`. Grep shows ProfileProvider import and usage in layout.tsx.
  </verify>
  <done>
Root layout wraps app content with ProfileProvider, enabling profile context throughout the application.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add ProfileSwitcher to navbar</name>
  <files>frontend/src/components/navbar.tsx</files>
  <action>
Modify `frontend/src/components/navbar.tsx` to include ProfileSwitcher:

1. Add imports:
```typescript
import { ProfileSwitcher } from "@/components/profile-switcher";
import { useProfile } from "@/contexts/profile-context";
```

2. Inside NavBar component, get profile context:
```typescript
const { currentProfile, isLoading } = useProfile();
```

3. Update the right side actions div to include:
   - ProfileSwitcher (rendered only when not loading)
   - Badge showing currentProfile?.name or "No Profile"
   - Remove or update the existing "Local Mode" badge

New right side structure:
```tsx
<div className="flex items-center gap-3">
  {!isLoading && <ProfileSwitcher />}
  <Badge variant="secondary" className="hidden sm:inline-flex">
    {currentProfile?.name || "No Profile"}
  </Badge>
</div>
```

4. Handle loading state in ProfileSwitcher display:
   - If isLoading, either show nothing or a small skeleton
   - The ProfileSwitcher component handles its own internal loading skeleton

AVOID: Showing ProfileSwitcher before context is ready (hydration issues). AVOID: Breaking existing navigation links.
  </action>
  <verify>
TypeScript compilation passes: `cd frontend && npx tsc --noEmit`. Grep shows ProfileSwitcher import and usage in navbar.tsx.
  </verify>
  <done>
Navbar displays ProfileSwitcher and current profile name, enabling users to switch profiles from any page.
  </done>
</task>

<task type="auto">
  <name>Task 3: Make library page profile-aware with refetch on switch</name>
  <files>frontend/src/app/librarie/page.tsx</files>
  <action>
Modify `frontend/src/app/librarie/page.tsx` to respond to profile changes:

1. Add import:
```typescript
import { useProfile } from "@/contexts/profile-context";
```

2. Inside LibrarieContent component, get profile context:
```typescript
const { currentProfile, isLoading: profileLoading } = useProfile();
```

3. Modify the initial fetch useEffect to:
   - Depend on `currentProfile?.id` (refetch when profile changes)
   - Wait for profile context to be ready before fetching
   - Add guard: `if (profileLoading) return;`

Updated useEffect:
```typescript
useEffect(() => {
  if (profileLoading) return; // Wait for profile context
  fetchAllClips();
}, [profileLoading, currentProfile?.id]);
```

4. Update loading state display:
   - If `profileLoading` is true, show loading spinner (profile context initializing)
   - If `loading` is true (clips fetching), show loading spinner
   - Combined: `if (profileLoading || loading)` for the spinner

5. Update the header subtitle to include profile context:
   - Optional: Show "Clips for {currentProfile?.name}" or keep existing text
   - At minimum, clips will automatically filter by profile via X-Profile-Id header

The X-Profile-Id header is automatically injected by api.ts (from 03-01), so the /library/all-clips endpoint will return only clips for the current profile.

AVOID: Fetching before profile context is ready (race condition, wrong data). AVOID: Not re-fetching when profile changes (stale data shown).
  </action>
  <verify>
TypeScript compilation passes: `cd frontend && npx tsc --noEmit`. Grep shows useProfile import in librarie/page.tsx. useEffect depends on currentProfile?.id.
  </verify>
  <done>
Library page waits for profile context and refetches clips when profile changes, showing only current profile's data.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete profile management system:
- ProfileProvider context with localStorage persistence
- ProfileSwitcher dropdown in navbar
- CreateProfileDialog for new profiles
- Profile-aware library page that refetches on profile switch
  </what-built>
  <how-to-verify>
1. Start the development servers:
   - Backend: `python run.py` (in project root)
   - Frontend: `cd frontend && npm run dev`

2. Open http://localhost:3000/librarie in browser

3. Verify profile dropdown appears in navbar (top right area)

4. Test profile switching:
   - Click the profile dropdown
   - If no profiles exist, only "Create New Profile" option shows
   - Click "Create New Profile"
   - Enter name "Test Profile" and optional description
   - Click Create
   - Verify toast shows success
   - Verify new profile appears in dropdown
   - Create a second profile "Test Profile 2"

5. Test profile switching behavior:
   - Switch between profiles using the dropdown
   - Verify the navbar badge updates to show current profile name
   - Verify the library page reloads (shows loading spinner briefly)

6. Test persistence:
   - Note which profile is selected
   - Refresh the page (F5)
   - Verify the same profile is still selected (not reset)

7. Expected visual:
   - Dropdown button shows current profile name
   - Radio indicator shows which profile is selected
   - Badge next to dropdown shows profile name
   - Library page shows clips (or empty state) for current profile
  </how-to-verify>
  <resume-signal>Type "approved" if profile switching works correctly, or describe any issues encountered</resume-signal>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `cd frontend && npx tsc --noEmit`
2. layout.tsx contains ProfileProvider wrapper: grep for "ProfileProvider"
3. navbar.tsx imports and renders ProfileSwitcher: grep for "ProfileSwitcher"
4. librarie/page.tsx imports useProfile: grep for "useProfile"
5. librarie/page.tsx useEffect depends on currentProfile: grep for "currentProfile?.id"
</verification>

<success_criteria>
- ProfileProvider wraps app content in layout.tsx
- ProfileSwitcher appears in navbar
- Current profile name shown in navbar badge
- Library page refetches when profile changes
- Profile selection persists across page refresh
- User visually confirms profile system works
</success_criteria>

<output>
After completion, create `.planning/phases/03-frontend-profile-ui/03-03-SUMMARY.md`
</output>
