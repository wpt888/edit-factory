---
phase: 26-frontend-resilience
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/hooks/use-polling.ts
  - frontend/src/hooks/index.ts
  - frontend/src/components/empty-state.tsx
  - frontend/src/app/library/page.tsx
  - frontend/src/app/librarie/page.tsx
  - frontend/src/app/scripts/page.tsx
  - frontend/src/app/pipeline/page.tsx
  - frontend/src/app/assembly/page.tsx
  - frontend/src/app/products/page.tsx
  - frontend/src/app/product-video/page.tsx
  - frontend/src/app/batch-generate/page.tsx
  - frontend/src/app/tts-library/page.tsx
  - frontend/src/app/usage/page.tsx
  - frontend/src/app/segments/page.tsx
autonomous: true
requirements:
  - FE-04
  - FE-05

must_haves:
  truths:
    - "Every data page shows an informative empty state when no data exists"
    - "Polling-based job tracking uses a single shared usePolling hook"
    - "Inline setInterval polling in library, pipeline, assembly, and tts-library pages replaced with shared hook"
  artifacts:
    - path: "frontend/src/hooks/use-polling.ts"
      provides: "Generic polling hook for any endpoint with configurable interval and callbacks"
      exports: ["usePolling"]
    - path: "frontend/src/components/empty-state.tsx"
      provides: "Reusable empty state component with icon, title, description, and action"
      exports: ["EmptyState"]
    - path: "frontend/src/hooks/index.ts"
      provides: "Re-exports usePolling"
      contains: "usePolling"
  key_links:
    - from: "frontend/src/app/library/page.tsx"
      to: "frontend/src/hooks/use-polling.ts"
      via: "import usePolling"
      pattern: "usePolling"
    - from: "frontend/src/app/pipeline/page.tsx"
      to: "frontend/src/hooks/use-polling.ts"
      via: "import usePolling"
      pattern: "usePolling"
    - from: "frontend/src/app/library/page.tsx"
      to: "frontend/src/components/empty-state.tsx"
      via: "import EmptyState"
      pattern: "EmptyState"
---

<objective>
Create a shared polling hook to replace all inline setInterval polling across pages, add a reusable EmptyState component, and wire empty states into every data page.

Purpose: Eliminate duplicated polling logic (currently in library, pipeline, assembly, tts-library as raw setInterval), and ensure users never see blank content areas when no data exists.
Output: Shared usePolling hook, EmptyState component, updated pages with empty states.
</objective>

<execution_context>
@/home/ukfdb/.claude/get-shit-done/workflows/execute-plan.md
@/home/ukfdb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@frontend/src/hooks/use-job-polling.ts
@frontend/src/hooks/use-batch-polling.ts
@frontend/src/hooks/index.ts
@frontend/src/app/library/page.tsx
@frontend/src/app/pipeline/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create shared usePolling hook and EmptyState component</name>
  <files>
    frontend/src/hooks/use-polling.ts
    frontend/src/hooks/index.ts
    frontend/src/components/empty-state.tsx
  </files>
  <action>
1. Create `frontend/src/hooks/use-polling.ts`:
   - "use client" directive
   - Generic hook: `usePolling<T>(options: UsePollingOptions<T>): UsePollingReturn<T>`
   - Options: `{ endpoint: string, interval?: number (default 3000), enabled?: boolean (default false), onData?: (data: T) => void, onError?: (error: Error) => void, shouldStop?: (data: T) => boolean }`
   - Return: `{ data: T | null, isPolling: boolean, error: Error | null, startPolling: () => void, stopPolling: () => void }`
   - Implementation:
     a. Uses useRef for interval ID and isCancelled flag
     b. When `enabled` becomes true OR `startPolling()` called, begins polling the endpoint via fetch
     c. On each successful response, calls onData, checks shouldStop — if true, stops polling
     d. On error, calls onError, retries with doubled interval (like existing hooks)
     e. `stopPolling()` clears interval and sets isCancelled
     f. Cleanup on unmount via useEffect return
   - This is a GENERIC polling primitive. The existing useJobPolling and useBatchPolling are specialized wrappers — do NOT modify or replace them. The usePolling hook is for inline setInterval replacements.

2. Update `frontend/src/hooks/index.ts`:
   - Add export: `export { usePolling } from "./use-polling"`

3. Create `frontend/src/components/empty-state.tsx`:
   - "use client" directive
   - Props: `{ icon?: ReactNode, title: string, description?: string, action?: { label: string, onClick: () => void } }`
   - Renders a centered flex column with:
     a. Icon area (if provided) — renders the passed ReactNode in a muted circle
     b. Title in text-lg font-medium text-gray-300
     c. Description in text-sm text-gray-500 (if provided)
     d. Action button (if provided) — styled with bg-blue-600 hover:bg-blue-700, rounded
   - Container: py-12 flex flex-col items-center justify-center gap-3
   - Export as named export `EmptyState`
  </action>
  <verify>
    - `cd frontend && npx tsc --noEmit --pretty 2>&1 | head -30` shows no type errors
    - usePolling exported from hooks/index.ts
    - EmptyState component exists with required props
  </verify>
  <done>
    Generic usePolling hook and EmptyState component ready for use across pages.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add empty states to all data pages and replace inline polling with usePolling</name>
  <files>
    frontend/src/app/library/page.tsx
    frontend/src/app/librarie/page.tsx
    frontend/src/app/scripts/page.tsx
    frontend/src/app/pipeline/page.tsx
    frontend/src/app/assembly/page.tsx
    frontend/src/app/products/page.tsx
    frontend/src/app/product-video/page.tsx
    frontend/src/app/batch-generate/page.tsx
    frontend/src/app/tts-library/page.tsx
    frontend/src/app/usage/page.tsx
    frontend/src/app/segments/page.tsx
  </files>
  <action>
This task has two parts: empty states and polling replacement.

**Part A — Add EmptyState to every data page:**

Import EmptyState from `@/components/empty-state` in each page. Add empty state rendering when the page's primary data array is empty and not loading. Use appropriate Romanian text for each:

- `library/page.tsx`: When projects array is empty — icon: FolderOpen, title: "Niciun proiect", description: "Creeaza primul proiect pentru a incepe.", action: button to trigger project creation
- `librarie/page.tsx`: When clips array is empty — icon: Film, title: "Nicio editare", description: "Clipurile procesate vor aparea aici."
- `scripts/page.tsx`: When scripts empty — icon: FileText, title: "Niciun script", description: "Genereaza un script pentru a incepe."
- `pipeline/page.tsx`: When no pipeline data — icon: Workflow, title: "Niciun pipeline", description: "Configureaza un pipeline pentru a genera video-uri."
- `assembly/page.tsx`: When no assembly data — icon: Layers, title: "Niciun assembly", description: "Creeaza un assembly pentru a combina segmente."
- `products/page.tsx`: When products empty — icon: Package, title: "Niciun produs", description: "Importa produse dintr-un feed sau adauga manual."
- `product-video/page.tsx`: When no product selected — icon: Video, title: "Selecteaza un produs", description: "Alege un produs din lista pentru a genera un video."
- `batch-generate/page.tsx`: When no batch — icon: Layers, title: "Nicio generare batch", description: "Selecteaza produse si configureaza o generare batch."
- `tts-library/page.tsx`: When audio files empty — icon: Mic, title: "Niciun fisier audio", description: "Fisierele TTS generate vor aparea aici."
- `usage/page.tsx`: When cost data empty — icon: BarChart3, title: "Nicio utilizare", description: "Costurile API vor fi inregistrate aici."
- `segments/page.tsx`: When segments empty — icon: Scissors, title: "Niciun segment", description: "Segmentele video selectate vor aparea aici."

Import icons from `lucide-react`. Only show empty state when data is loaded (not during initial loading). If page already has a loading spinner, show empty state after loading completes with empty result.

**Part B — Replace inline setInterval polling with usePolling:**

Target the 4 pages that use raw setInterval for job polling (NOT useJobPolling/useBatchPolling consumers — those are fine):

1. `library/page.tsx` lines ~536-573 (generation progress polling via setInterval):
   - Replace the raw setInterval that polls `/library/projects/{id}/generate/progress` with usePolling hook
   - Keep the same onData logic (update progress state)
   - shouldStop when status is "completed" or "failed"

2. `library/page.tsx` lines ~926 (render status polling via setInterval):
   - Replace the raw setInterval that polls clip render status
   - shouldStop when clip final_status is "completed" or "failed"

3. `pipeline/page.tsx` line ~128 (render polling via setInterval):
   - Replace the setInterval polling render status with usePolling
   - shouldStop when all renders complete

4. `assembly/page.tsx` line ~94 (render polling via setInterval):
   - Replace the setInterval polling render status with usePolling
   - shouldStop when render completes

5. `tts-library/page.tsx` line ~97 (job polling via setInterval):
   - Replace the setInterval polling job status with usePolling
   - shouldStop when job status is "completed" or "failed"

For each replacement:
- Import usePolling from `@/hooks`
- Replace the setInterval block with usePolling call
- Preserve all existing callbacks (onData updates, completion handling)
- Remove the manual clearInterval cleanup since usePolling handles it
- Keep the same polling interval as the original code

IMPORTANT: Do NOT modify useJobPolling or useBatchPolling hooks — they are specialized and already work. Only replace raw setInterval patterns.
  </action>
  <verify>
    - `cd frontend && npx tsc --noEmit --pretty 2>&1 | head -30` shows no type errors
    - `grep -r "setInterval" frontend/src/app/ --include="*.tsx" | grep -v node_modules` shows no raw setInterval for polling (timer setIntervals for elapsed time display are OK)
    - EmptyState component renders on each page when data array is empty
  </verify>
  <done>
    All data pages show informative empty states. All inline setInterval polling replaced with shared usePolling hook. useJobPolling and useBatchPolling remain untouched.
  </done>
</task>

</tasks>

<verification>
1. `frontend/src/hooks/use-polling.ts` exports generic usePolling hook
2. `frontend/src/components/empty-state.tsx` exports EmptyState component
3. Every data page imports and renders EmptyState when data is empty
4. No raw setInterval polling remains in page files (only timer intervals for display)
5. TypeScript compiles: `cd frontend && npx tsc --noEmit`
6. Existing useJobPolling and useBatchPolling hooks untouched
</verification>

<success_criteria>
- Every page shows an informative empty state when no data exists (no blank content)
- All inline polling uses shared usePolling hook
- useJobPolling (specialized) and useBatchPolling (specialized) unchanged
- TypeScript compiles without errors
- Empty states use Romanian text consistent with existing UI
</success_criteria>

<output>
After completion, create `.planning/phases/26-frontend-resilience/26-02-SUMMARY.md`
</output>
