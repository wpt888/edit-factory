---
phase: 26-frontend-resilience
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/app/global-error.tsx
  - frontend/src/components/error-boundary.tsx
  - frontend/src/lib/api.ts
  - frontend/src/lib/api-error.ts
autonomous: true
requirements:
  - FE-01
  - FE-02
  - FE-03

must_haves:
  truths:
    - "An unhandled React error shows a styled fallback UI instead of a white blank screen"
    - "All API errors surface as sonner toast notifications consistently (no alert() or console-only)"
    - "API requests time out after 30 seconds and GET requests retry up to 2 times on failure"
  artifacts:
    - path: "frontend/src/app/global-error.tsx"
      provides: "Next.js root error boundary for unhandled errors"
      contains: "global-error"
    - path: "frontend/src/components/error-boundary.tsx"
      provides: "Reusable React error boundary component"
      contains: "ErrorBoundary"
    - path: "frontend/src/lib/api-error.ts"
      provides: "Centralized error handler that converts API errors to sonner toasts"
      exports: ["handleApiError", "ApiError"]
    - path: "frontend/src/lib/api.ts"
      provides: "API client with timeout, retry, and centralized error handling"
      contains: "AbortSignal.timeout"
  key_links:
    - from: "frontend/src/lib/api.ts"
      to: "frontend/src/lib/api-error.ts"
      via: "import handleApiError"
      pattern: "handleApiError"
    - from: "frontend/src/app/global-error.tsx"
      to: "error boundary UI"
      via: "Next.js error.tsx convention"
      pattern: "export default function GlobalError"
---

<objective>
Add global React error boundary, centralize all API error handling through sonner toasts, and harden the API client with timeout and retry logic.

Purpose: Prevent white-screen crashes from unhandled errors, eliminate the inconsistent mix of alert()/console.error()/toast.error() across pages, and make API calls resilient to transient failures.
Output: Error boundary components, centralized error utility, hardened API client.
</objective>

<execution_context>
@/home/ukfdb/.claude/get-shit-done/workflows/execute-plan.md
@/home/ukfdb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@frontend/src/lib/api.ts
@frontend/src/app/layout.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create global error boundary and reusable ErrorBoundary component</name>
  <files>
    frontend/src/app/global-error.tsx
    frontend/src/components/error-boundary.tsx
  </files>
  <action>
1. Create `frontend/src/app/global-error.tsx` — the Next.js App Router root error boundary:
   - Must be a Client Component ("use client")
   - Receives `error` and `reset` props
   - Shows a styled fallback UI matching the dark theme (dark background, white text)
   - Display: error icon, "Ceva nu a mers bine" heading, error.message in a code block, and a "Incearca din nou" button that calls reset()
   - Also a "Inapoi acasa" link to "/"
   - Use Tailwind classes consistent with the existing dark-themed app (bg-gray-900, text-white, etc.)

2. Create `frontend/src/components/error-boundary.tsx` — a reusable class-based React error boundary:
   - "use client" directive
   - Props: `children`, `fallback?: ReactNode`, `onError?: (error: Error, info: ErrorInfo) => void`
   - In componentDidCatch, call onError callback if provided and console.error the error
   - Default fallback: card with "A aparut o eroare" message and "Reincearca" button
   - hasError state tracks whether to show fallback
   - Reset button sets hasError=false to retry rendering children
   - Export as named export `ErrorBoundary`
  </action>
  <verify>
    - File `frontend/src/app/global-error.tsx` exists and exports a default function component
    - File `frontend/src/components/error-boundary.tsx` exists and exports ErrorBoundary class
    - `cd frontend && npx tsc --noEmit --pretty 2>&1 | head -30` shows no errors in these files
  </verify>
  <done>
    global-error.tsx catches unhandled errors at root level with styled fallback UI. ErrorBoundary component available for wrapping any page section.
  </done>
</task>

<task type="auto">
  <name>Task 2: Centralize API error handling and harden API client with timeout/retry</name>
  <files>
    frontend/src/lib/api-error.ts
    frontend/src/lib/api.ts
  </files>
  <action>
1. Create `frontend/src/lib/api-error.ts`:
   - Define `ApiError` class extending Error with `status: number`, `detail: string`, `isTimeout: boolean` fields
   - Export `handleApiError(error: unknown, context?: string): void` function that:
     a. If error is ApiError with status 429: `toast.error("Prea multe cereri. Incearca mai tarziu.")`
     b. If error is ApiError with status 413: `toast.error("Fisierul este prea mare.")`
     c. If error is ApiError with status 409: `toast.error("Operatiune in curs. Asteapta finalizarea.")`
     d. If error is ApiError with isTimeout: `toast.error("Cererea a expirat. Incearca din nou.")`
     e. If error is ApiError with status >= 500: `toast.error("Eroare de server. Incearca mai tarziu.")`
     f. If error is ApiError with detail: `toast.error(error.detail)`
     g. Default: `toast.error(context || "A aparut o eroare neasteptata.")`
   - Import toast from "sonner"

2. Modify `frontend/src/lib/api.ts` — add timeout and retry to `apiFetch`:
   - Add `timeout?: number` and `retry?: number` to `FetchOptions` interface (default timeout=30000ms, retry not set)
   - In `apiFetch`, create an AbortSignal using `AbortSignal.timeout(timeout)` if no signal provided
   - After fetch, if `!response.ok`, parse response body for `detail` field, throw new `ApiError` with status, detail, isTimeout=false
   - Wrap fetch in try/catch: if error.name === "TimeoutError" or "AbortError", throw new `ApiError` with status=0, isTimeout=true
   - Add a new exported function `apiGetWithRetry(endpoint, options)` that wraps `apiGet` with retry logic: up to 2 retries on network/timeout errors (not on 4xx), with 1-second delay between retries. This avoids breaking existing apiGet callers.
   - Import `ApiError` from `./api-error`
   - Re-export `ApiError` and `handleApiError` from api.ts for convenience: `export { ApiError, handleApiError } from "./api-error"`
  </action>
  <verify>
    - `cd frontend && npx tsc --noEmit --pretty 2>&1 | head -30` shows no type errors
    - api.ts exports apiGetWithRetry function
    - api-error.ts exports handleApiError and ApiError
    - Existing apiGet/apiPost/apiFetch signatures unchanged (backward compatible)
  </verify>
  <done>
    All API errors can be handled via handleApiError() producing sonner toasts. API client supports timeout (30s default) and retry for GET requests. No existing callers broken.
  </done>
</task>

</tasks>

<verification>
1. `frontend/src/app/global-error.tsx` exists with proper error boundary
2. `frontend/src/components/error-boundary.tsx` exports reusable ErrorBoundary
3. `frontend/src/lib/api-error.ts` exports handleApiError using sonner toast
4. `frontend/src/lib/api.ts` has timeout support and apiGetWithRetry
5. TypeScript compiles without errors: `cd frontend && npx tsc --noEmit`
6. No existing imports broken (apiGet, apiPost, apiFetch, apiUpload, apiDelete unchanged)
</verification>

<success_criteria>
- Unhandled React errors show styled dark-themed fallback UI (not white screen)
- handleApiError() produces consistent sonner toast for any API error type
- API requests have 30s timeout by default
- apiGetWithRetry retries GET requests up to 2 times on transient failures
- All existing API client consumers continue working without changes
</success_criteria>

<output>
After completion, create `.planning/phases/26-frontend-resilience/26-01-SUMMARY.md`
</output>
