---
phase: 02-backend-profile-context
plan: 04
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - app/api/segments_routes.py
  - app/api/postiz_routes.py
  - app/api/routes.py
autonomous: true

must_haves:
  truths:
    - "Segments routes filter source videos and segments by profile_id"
    - "Postiz routes pass profile_id to PostizPublisher methods"
    - "Main routes.py background tasks receive profile_id parameter"
    - "CostTracker calls in routes.py include profile_id"
    - "JobStorage calls in routes.py include profile_id"
  artifacts:
    - path: "app/api/segments_routes.py"
      provides: "Profile-aware segment routes"
      contains: "get_profile_context"
    - path: "app/api/postiz_routes.py"
      provides: "Profile-aware publishing routes"
      contains: "get_profile_context"
    - path: "app/api/routes.py"
      provides: "Profile-aware main routes and background tasks"
      contains: "get_profile_context"
  key_links:
    - from: "segments_routes.py"
      to: "auth.py"
      via: "Depends(get_profile_context)"
      pattern: "Depends\\(get_profile_context\\)"
    - from: "postiz_routes.py"
      to: "PostizPublisher"
      via: "profile_id parameter"
      pattern: "profile_id=profile\\.profile_id"
---

<objective>
Retrofit segments_routes.py, postiz_routes.py, and routes.py with profile context injection.

Purpose: Complete the backend profile-awareness by updating the remaining route files. Segments handles manual video curation, Postiz handles publishing, and routes.py handles video processing jobs.

Output: All routes across these three files require/validate profile context, all background tasks receive profile_id, all service calls include profile_id.
</objective>

<execution_context>
@/home/ukfdb/.claude/get-shit-done/workflows/execute-plan.md
@/home/ukfdb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-backend-profile-context/02-CONTEXT.md
@.planning/phases/02-backend-profile-context/02-RESEARCH.md
@.planning/phases/02-backend-profile-context/02-01-SUMMARY.md
@.planning/phases/02-backend-profile-context/02-02-SUMMARY.md

# Source files to modify
@app/api/segments_routes.py
@app/api/postiz_routes.py
@app/api/routes.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update segments_routes.py with profile context</name>
  <files>app/api/segments_routes.py</files>
  <action>
Update segments_routes.py with profile context for all routes.

**1. Add import at top:**
```python
from app.api.auth import ProfileContext, get_profile_context
```

**2. NOTE: Segments system uses different tables**
The segments system uses:
- `source_videos` table (stores uploaded source videos)
- `video_segments` table (stores marked segments within source videos)
- `editai_project_segments` table (links segments to projects)

These tables were NOT modified in Phase 1 to add profile_id (they don't have direct profile ownership - they're linked through projects).

**Strategy for segments:**
- Source videos belong to a profile (add profile_id filter on source_videos if column exists)
- If source_videos doesn't have profile_id column yet, segments routes should still require authentication (via get_profile_context) for logging and future readiness
- Project-segment links are validated through project ownership

**3. Update source video routes:**

For routes like `POST /source-videos` (upload):
```python
@router.post("/source-videos")
async def upload_source_video(
    background_tasks: BackgroundTasks,
    video: UploadFile = File(...),
    name: str = Form(...),
    profile: ProfileContext = Depends(get_profile_context)  # NEW
):
```

Add profile logging:
```python
logger.info(f"[Profile {profile.profile_id}] Uploading source video: {name}")
```

If source_videos table has profile_id column, add to insert. If not, just log.

**4. Update GET /source-videos:**
```python
@router.get("/source-videos")
async def list_source_videos(
    profile: ProfileContext = Depends(get_profile_context)
):
```

Filter by profile_id if column exists on table.

**5. Update segment creation/listing routes:**
Add profile dependency for authentication and logging.

**6. Update extract_segments_task background task:**
```python
async def extract_segments_task(
    segment_id: str,
    profile_id: str,  # NEW
    ...
):
    logger.info(f"[Profile {profile_id}] Extracting segment: {segment_id}")
```

Pass profile_id when calling background task:
```python
background_tasks.add_task(
    extract_segments_task,
    segment_id=segment_id,
    profile_id=profile.profile_id,  # NEW
    ...
)
```

**7. Update project-segment linking routes:**
When linking segments to projects, verify project ownership:
```python
# Verify project belongs to profile
project = supabase.table("editai_projects")\
    .select("id")\
    .eq("id", project_id)\
    .eq("profile_id", profile.profile_id)\
    .single()\
    .execute()

if not project.data:
    raise HTTPException(status_code=404, detail="Project not found")
```

IMPORTANT: If source_videos table doesn't have profile_id column, that's OK - add the dependency anyway for consistent authentication and logging. The column can be added in a future migration if needed.
  </action>
  <verify>
Run: `grep -c "get_profile_context" app/api/segments_routes.py` returns at least 4
  </verify>
  <done>
segments_routes.py routes use get_profile_context, log profile context, and verify project ownership where applicable.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update postiz_routes.py with profile context</name>
  <files>app/api/postiz_routes.py</files>
  <action>
Update postiz_routes.py with profile context for all routes.

**1. Add import at top:**
```python
from app.api.auth import ProfileContext, get_profile_context
```

**2. Update GET /integrations:**
```python
@router.get("/integrations")
async def get_integrations(
    profile: ProfileContext = Depends(get_profile_context)
):
```

Pass profile_id to PostizPublisher:
```python
from app.services.postiz_service import get_postiz_publisher
publisher = get_postiz_publisher()
integrations = await publisher.get_integrations(profile_id=profile.profile_id)
```

**3. Update POST /upload:**
```python
@router.post("/upload")
async def upload_media(
    request: UploadRequest,
    profile: ProfileContext = Depends(get_profile_context)
):
```

Pass profile_id:
```python
media = await publisher.upload_video(Path(video_path), profile_id=profile.profile_id)
```

**4. Update POST /publish:**
```python
@router.post("/publish")
async def publish_clip(
    request: PublishRequest,
    background_tasks: BackgroundTasks,
    profile: ProfileContext = Depends(get_profile_context)
):
```

Verify clip ownership (clip belongs to project that belongs to profile):
```python
# Get clip and verify ownership chain
clip = supabase.table("editai_clips")\
    .select("*, editai_projects!inner(profile_id)")\
    .eq("id", request.clip_id)\
    .single()\
    .execute()

if not clip.data or clip.data["editai_projects"]["profile_id"] != profile.profile_id:
    raise HTTPException(status_code=404, detail="Clip not found")
```

Pass profile_id to background task:
```python
background_tasks.add_task(
    _publish_clip_task,
    clip_id=request.clip_id,
    profile_id=profile.profile_id,  # NEW
    caption=request.caption,
    integration_ids=request.integration_ids,
    schedule_date=schedule_date
)
```

**5. Update _publish_clip_task:**
```python
async def _publish_clip_task(
    clip_id: str,
    profile_id: str,  # NEW
    caption: str,
    integration_ids: List[str],
    schedule_date: Optional[datetime]
):
    logger.info(f"[Profile {profile_id}] Publishing clip: {clip_id}")
```

Pass profile_id to PostizPublisher.create_post:
```python
result = await publisher.create_post(
    media_id=media.id,
    media_path=media.path,
    caption=caption,
    integration_ids=integration_ids,
    schedule_date=schedule_date,
    integrations_info=integrations_info,
    profile_id=profile_id  # NEW
)
```

**6. Update bulk publish routes similarly:**
- POST /bulk-publish
- _bulk_publish_task

**7. Update GET /status:**
```python
@router.get("/status")
async def get_postiz_status(
    profile: ProfileContext = Depends(get_profile_context)
):
```

This route returns Postiz connection status - profile context is for auth/logging.
  </action>
  <verify>
Run: `grep -c "get_profile_context" app/api/postiz_routes.py` returns at least 5
  </verify>
  <done>
postiz_routes.py routes use get_profile_context, verify clip ownership, and pass profile_id to PostizPublisher methods.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update routes.py with profile context</name>
  <files>app/api/routes.py</files>
  <action>
Update routes.py (main video processing routes) with profile context.

**1. Add import at top:**
```python
from app.api.auth import ProfileContext, get_profile_context
```

**2. Identify routes that need profile context:**

Look for routes that:
- Create jobs (need to store profile_id)
- Track costs (need to pass profile_id to CostTracker)
- Access user data

Common routes in routes.py:
- POST /jobs - video processing job creation
- GET /jobs/{job_id} - job status
- POST /tts/generate - TTS generation
- POST /voice-mute - voice muting
- GET /costs - cost summary
- GET /usage - usage statistics

**3. Update POST /jobs (video processing):**
```python
@router.post("/jobs")
async def create_job(
    background_tasks: BackgroundTasks,
    video: UploadFile = File(...),
    ...,
    profile: ProfileContext = Depends(get_profile_context)  # NEW
):
```

Create job with profile_id:
```python
from app.services.job_storage import get_job_storage
job_storage = get_job_storage()
job_storage.create_job(job_data, profile_id=profile.profile_id)
```

Pass to background task:
```python
background_tasks.add_task(process_job, job_id, profile.profile_id)
```

**4. Update process_job background task:**
```python
async def process_job(job_id: str, profile_id: str):
    logger.info(f"[Profile {profile_id}] Processing job: {job_id}")
```

Pass profile_id to CostTracker when logging Gemini analysis:
```python
tracker = get_cost_tracker()
tracker.log_gemini_analysis(job_id, frames, profile_id=profile_id)
```

**5. Update TTS routes:**

POST /tts/generate:
```python
@router.post("/tts/generate")
async def generate_tts(
    ...,
    profile: ProfileContext = Depends(get_profile_context)
):
```

Pass profile_id to cost tracking:
```python
tracker.log_elevenlabs_tts(job_id, len(text), profile_id=profile.profile_id)
```

**6. Update GET /costs route:**
```python
@router.get("/costs")
async def get_costs(
    profile: ProfileContext = Depends(get_profile_context)
):
    tracker = get_cost_tracker()
    return tracker.get_summary(profile_id=profile.profile_id)  # Filter by profile
```

**7. Update GET /usage route:**
Similar to costs - filter by profile.

**8. Update all other background tasks in routes.py:**
- process_tts_job
- process_voice_mute_job
- process_multi_video_job
- process_tts_generate_job

All should:
- Accept profile_id parameter
- Log with [Profile {profile_id}] prefix
- Pass profile_id to JobStorage.update_job and CostTracker calls

**9. Public routes (no profile context needed):**
- GET /health - system health check
- GET /gemini/status - API connectivity check

These remain public (no profile dependency).
  </action>
  <verify>
Run: `grep -c "get_profile_context" app/api/routes.py` returns at least 6
  </verify>
  <done>
routes.py routes use get_profile_context where appropriate, all background tasks accept profile_id, all CostTracker/JobStorage calls include profile_id.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Import check for all files:**
   ```bash
   for f in app/api/segments_routes.py app/api/postiz_routes.py app/api/routes.py; do
     echo "$f:"; grep "get_profile_context" "$f" | head -1
   done
   ```

2. **Profile context usage count:**
   ```bash
   grep -c "Depends(get_profile_context)" app/api/segments_routes.py app/api/postiz_routes.py app/api/routes.py
   ```

3. **Background task signature check:**
   ```bash
   grep -n "async def process_\|async def _.*_task" app/api/routes.py app/api/postiz_routes.py | head -10
   ```
   Verify each shows profile_id in signature.

4. **Syntax check:**
   ```bash
   python -c "
   from app.api.segments_routes import router as seg
   from app.api.postiz_routes import router as post
   from app.api.routes import router as main
   print('All routers import OK')
   "
   ```

5. **Server startup check:**
   ```bash
   python -c "from app.main import app; print(f'Total routes: {len(app.routes)}')"
   ```
</verification>

<success_criteria>
- segments_routes.py: All routes use get_profile_context, extract_segments_task accepts profile_id
- postiz_routes.py: All routes use get_profile_context, clip ownership verified, _publish_clip_task and _bulk_publish_task accept profile_id
- routes.py: Job creation routes use get_profile_context, all background tasks accept profile_id, GET /costs and /usage filter by profile_id
- All CostTracker calls include profile_id parameter
- All JobStorage calls include profile_id parameter
- Public routes (health, gemini/status) remain without profile context
</success_criteria>

<output>
After completion, create `.planning/phases/02-backend-profile-context/02-04-SUMMARY.md`
</output>
