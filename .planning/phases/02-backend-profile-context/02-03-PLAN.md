---
phase: 02-backend-profile-context
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - app/api/library_routes.py
autonomous: true

must_haves:
  truths:
    - "User's projects list shows only their profile's projects (not all projects)"
    - "User cannot access another profile's project (returns 404)"
    - "Background video generation tracks costs to the correct profile"
    - "Background video generation creates jobs under the correct profile"
  artifacts:
    - path: "app/api/library_routes.py"
      provides: "Profile-aware library routes and background tasks"
      contains: "get_profile_context"
  key_links:
    - from: "app/api/library_routes.py"
      to: "app/api/auth.py"
      via: "Depends(get_profile_context)"
      pattern: "Depends\\(get_profile_context\\)"
    - from: "library route handlers"
      to: "background tasks"
      via: "profile_id parameter"
      pattern: "profile_id=profile\\.profile_id"
---

<objective>
Retrofit library_routes.py with profile context injection for all routes and background tasks.

Purpose: library_routes.py is the core of the application - it handles projects, clips, generation, and exports. Making it profile-aware ensures all video content is properly isolated per store profile.

Output: All library routes require/validate profile context, all Supabase queries filter by profile_id, all background tasks receive and use profile_id.

**SCOPE NOTE:** This file is ~2000+ lines with 20+ routes and multiple background tasks. The changes are mechanical (add dependency, add filter, pass parameter) but numerous. Take care to update ALL locations systematically.
</objective>

<execution_context>
@/home/ukfdb/.claude/get-shit-done/workflows/execute-plan.md
@/home/ukfdb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-backend-profile-context/02-CONTEXT.md
@.planning/phases/02-backend-profile-context/02-RESEARCH.md
@.planning/phases/02-backend-profile-context/02-01-SUMMARY.md

# Source file to modify
@app/api/library_routes.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add imports and update project routes with profile context</name>
  <files>app/api/library_routes.py</files>
  <action>
Update library_routes.py to import and use profile context.

**1. Add imports at top of file (after existing imports):**
```python
from app.api.auth import ProfileContext, get_profile_context
```

**2. Update create_project route:**
Change from:
```python
@router.post("/projects", response_model=ProjectResponse)
async def create_project(project: ProjectCreate):
```
To:
```python
@router.post("/projects", response_model=ProjectResponse)
async def create_project(
    project: ProjectCreate,
    profile: ProfileContext = Depends(get_profile_context)
):
```

Add profile_id to the Supabase insert:
```python
result = supabase.table("editai_projects").insert({
    "name": project.name,
    "description": project.description,
    "target_duration": project.target_duration,
    "context_text": project.context_text,
    "status": "draft",
    "profile_id": profile.profile_id  # NEW: Add profile context
}).execute()
```

Add logging:
```python
logger.info(f"[Profile {profile.profile_id}] Created project: {proj['id']}")
```

**3. Update list_projects route:**
```python
@router.get("/projects")
async def list_projects(
    status: Optional[str] = None,
    profile: ProfileContext = Depends(get_profile_context)
):
```

Filter by profile_id:
```python
query = supabase.table("editai_projects")\
    .select("*")\
    .eq("profile_id", profile.profile_id)\  # NEW: Filter by profile
    .order("created_at", desc=True)
```

**4. Update get_project route:**
```python
@router.get("/projects/{project_id}", response_model=ProjectResponse)
async def get_project(
    project_id: str,
    profile: ProfileContext = Depends(get_profile_context)
):
```

Add ownership check:
```python
result = supabase.table("editai_projects")\
    .select("*")\
    .eq("id", project_id)\
    .eq("profile_id", profile.profile_id)\  # NEW: Ownership check
    .single()\
    .execute()
```

**5. Update get_project_progress route:**
Add profile dependency (even though progress is in-memory, project lookup needs profile filter):
```python
@router.get("/projects/{project_id}/progress")
async def get_project_progress(
    project_id: str,
    profile: ProfileContext = Depends(get_profile_context)
):
```

**6. Update update_project route:**
```python
@router.patch("/projects/{project_id}")
async def update_project(
    project_id: str,
    updates: dict,
    profile: ProfileContext = Depends(get_profile_context)
):
```

Add profile filter to update:
```python
result = supabase.table("editai_projects")\
    .update(filtered_updates)\
    .eq("id", project_id)\
    .eq("profile_id", profile.profile_id)\  # NEW: Ownership check
    .execute()
```

**7. Update delete_project route:**
```python
@router.delete("/projects/{project_id}")
async def delete_project(
    project_id: str,
    profile: ProfileContext = Depends(get_profile_context)
):
```

Add profile filter to both clips query and project delete.

IMPORTANT: For every route, ensure the .eq("profile_id", profile.profile_id) filter is added to prevent cross-profile access.
  </action>
  <verify>
Run: `grep -c "get_profile_context" app/api/library_routes.py` returns at least 6 (one per route modified)
  </verify>
  <done>
Project routes (create, list, get, progress, update, delete) all use get_profile_context dependency and filter queries by profile_id.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update clip routes and generate endpoints with profile context</name>
  <files>app/api/library_routes.py</files>
  <action>
Continue updating library_routes.py with profile context for clip operations.

**Find and update these routes with profile dependency and query filters:**

1. **GET /projects/{project_id}/clips** - list clips
   - Add: `profile: ProfileContext = Depends(get_profile_context)`
   - Verify project ownership before returning clips

2. **POST /projects/{project_id}/clips** - create clip
   - Add profile dependency
   - Verify project ownership

3. **GET /projects/{project_id}/clips/{clip_id}** - get single clip
   - Add profile dependency
   - Verify project ownership

4. **PATCH /projects/{project_id}/clips/{clip_id}** - update clip
   - Add profile dependency
   - Verify project ownership before update

5. **DELETE /projects/{project_id}/clips/{clip_id}** - delete clip
   - Add profile dependency
   - Verify project ownership

6. **POST /projects/{project_id}/generate** - generate raw clips
   - Add profile dependency
   - **CRITICAL**: Pass profile_id to background task:
   ```python
   background_tasks.add_task(
       _generate_raw_clips_task,
       project_id=project_id,
       profile_id=profile.profile_id,  # NEW: Pass to background task
       video_path=str(video_path),
       variant_count=variant_count,
       ...
   )
   ```

7. **POST /projects/{project_id}/generate-from-segments** - generate from manual segments
   - Add profile dependency
   - Pass profile_id to background task

**Helper function for ownership verification:**
Create a helper to verify project ownership (reduces code duplication):

```python
def verify_project_ownership(supabase, project_id: str, profile_id: str) -> dict:
    """Verify project exists and belongs to profile. Returns project or raises 404."""
    result = supabase.table("editai_projects")\
        .select("*")\
        .eq("id", project_id)\
        .eq("profile_id", profile_id)\
        .single()\
        .execute()

    if not result.data:
        raise HTTPException(status_code=404, detail="Project not found")

    return result.data
```

Use this helper at the start of clip routes:
```python
verify_project_ownership(supabase, project_id, profile.profile_id)
```
  </action>
  <verify>
Run: `grep -c "profile_id=profile.profile_id" app/api/library_routes.py` shows multiple occurrences in generate routes
  </verify>
  <done>
Clip routes and generate endpoints all use profile context, verify ownership, and pass profile_id to background tasks.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update background tasks to use profile_id with CostTracker and JobStorage</name>
  <files>app/api/library_routes.py</files>
  <action>
Update all background task functions to accept and use profile_id parameter, including explicit wiring to CostTracker and JobStorage.

**1. Update _generate_raw_clips_task:**
Change signature from:
```python
async def _generate_raw_clips_task(
    project_id: str,
    video_path: str,
    variant_count: int,
    ...
):
```
To:
```python
async def _generate_raw_clips_task(
    project_id: str,
    profile_id: str,  # NEW parameter
    video_path: str,
    variant_count: int,
    ...
):
```

Add profile logging at start:
```python
logger.info(f"[Profile {profile_id}] Starting raw clip generation for project {project_id}")
```

**EXPLICIT WIRING - Add these calls if they don't already exist in _generate_raw_clips_task:**

If the task uses Gemini analysis (check for `gemini` or `analyze` in the function):
```python
from app.services.cost_tracker import get_cost_tracker
tracker = get_cost_tracker()
# After any Gemini API call that analyzes frames:
tracker.log_gemini_analysis(job_id, frames_analyzed, profile_id=profile_id)
```

If the task creates/updates jobs (check for `job_storage` or `create_job` in the function):
```python
from app.services.job_storage import get_job_storage
job_storage = get_job_storage()
# When creating job:
job_storage.create_job(job_data, profile_id=profile_id)
# When updating job:
job_storage.update_job(job_id, updates, profile_id=profile_id)
```

**2. Update _generate_from_segments_task:**
Same pattern - add profile_id parameter, logging, and service calls.

**3. Update _render_final_clip_task:**
Add profile_id parameter:
```python
async def _render_final_clip_task(
    clip_id: str,
    project_id: str,
    profile_id: str,  # NEW
    ...
):
```

**EXPLICIT WIRING - This task uses TTS, so add:**
```python
from app.services.cost_tracker import get_cost_tracker
tracker = get_cost_tracker()
# After ElevenLabs TTS generation:
tracker.log_elevenlabs_tts(job_id, len(tts_text), profile_id=profile_id)
```

**4. Update _export_clips_task (if exists):**
Same pattern.

**5. Update any other background tasks in the file:**
Search for `async def _` and `def _` task functions and add profile_id parameter to each.

**6. Update all background_tasks.add_task calls:**
Ensure every call passes profile_id:
```python
background_tasks.add_task(
    _render_final_clip_task,
    clip_id=clip_id,
    project_id=project_id,
    profile_id=profile.profile_id,  # NEW
    ...
)
```

**Logging pattern for all background tasks:**
```python
logger.info(f"[Profile {profile_id}] {action} - project: {project_id}")
logger.error(f"[Profile {profile_id}] Error: {e}")
```

**VERIFICATION CHECKLIST for this task:**
- [ ] _generate_raw_clips_task has profile_id param AND uses it
- [ ] _generate_from_segments_task has profile_id param AND uses it
- [ ] _render_final_clip_task has profile_id param AND uses it
- [ ] All CostTracker.log_* calls include profile_id=profile_id
- [ ] All JobStorage.create_job/update_job calls include profile_id=profile_id
- [ ] All background_tasks.add_task() calls pass profile_id=profile.profile_id
  </action>
  <verify>
Run multiple checks:
```bash
# Check task signatures have profile_id
grep -n "def _.*_task\|async def _.*_task" app/api/library_routes.py | head -10

# Check CostTracker calls include profile_id
grep -n "log_elevenlabs_tts\|log_gemini_analysis" app/api/library_routes.py | grep -v "^#"

# Check background_tasks.add_task passes profile_id
grep -n "background_tasks.add_task" app/api/library_routes.py | head -5
```
Verify each task signature includes profile_id and service calls include profile_id parameter.
  </verify>
  <done>
All background task functions accept profile_id parameter, include it in logging, and pass it to CostTracker/JobStorage calls. The wiring is explicit and verifiable.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Import check:**
   ```bash
   grep "from app.api.auth import.*get_profile_context" app/api/library_routes.py
   ```

2. **Route count check:**
   ```bash
   grep -c "Depends(get_profile_context)" app/api/library_routes.py
   ```
   Should be 10+ (all project and clip routes)

3. **Background task check:**
   ```bash
   grep -c "profile_id:" app/api/library_routes.py
   ```
   Should show profile_id being passed in multiple places

4. **CostTracker/JobStorage wiring check:**
   ```bash
   grep -E "log_(elevenlabs|gemini).*profile_id|create_job.*profile_id|update_job.*profile_id" app/api/library_routes.py
   ```
   Should show service calls with profile_id parameter

5. **No profile-less project queries:**
   ```bash
   grep 'table("editai_projects")' app/api/library_routes.py | grep -v profile_id
   ```
   Should return empty (all project queries include profile_id filter)

6. **Syntax check:**
   ```bash
   python -c "from app.api.library_routes import router; print('OK')"
   ```
</verification>

<success_criteria>
- All project routes (create, list, get, progress, update, delete) use get_profile_context
- All clip routes verify project ownership via profile_id filter
- All background tasks accept profile_id parameter
- All CostTracker calls (log_elevenlabs_tts, log_gemini_analysis) in background tasks include profile_id
- All JobStorage calls (create_job, update_job) in background tasks include profile_id
- Logging includes [Profile {id}] prefix
- No Supabase query on editai_projects exists without profile_id filter
</success_criteria>

<output>
After completion, create `.planning/phases/02-backend-profile-context/02-03-SUMMARY.md`
</output>
