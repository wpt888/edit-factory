---
phase: 02-backend-profile-context
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - app/services/job_storage.py
  - app/services/cost_tracker.py
  - app/services/postiz_service.py
autonomous: true

must_haves:
  truths:
    - "Jobs can be filtered by profile when listing (user sees only their profile's jobs)"
    - "Cost summaries can be filtered by profile (user sees only their profile's costs)"
    - "Publishing logs show which profile initiated the action (for debugging per-store issues)"
  artifacts:
    - path: "app/services/job_storage.py"
      provides: "Profile-aware job storage methods"
      contains: "profile_id"
    - path: "app/services/cost_tracker.py"
      provides: "Profile-aware cost tracking methods"
      contains: "profile_id"
    - path: "app/services/postiz_service.py"
      provides: "Profile-aware publishing methods"
      contains: "profile_id"
  key_links:
    - from: "app/services/job_storage.py"
      to: "jobs table"
      via: "Supabase insert with profile_id"
      pattern: '"profile_id":'
    - from: "app/services/cost_tracker.py"
      to: "api_costs table"
      via: "Supabase insert with profile_id"
      pattern: '"profile_id":'
---

<objective>
Update service layer methods to accept profile_id parameter for multi-tenant data isolation.

Purpose: Services are singletons that can't store profile state. By adding profile_id as method parameters, each API call can pass its profile context, enabling per-profile data tracking without breaking the singleton pattern.

Output: JobStorage, CostTracker, and PostizPublisher methods that accept and use profile_id for database operations and logging.
</objective>

<execution_context>
@/home/ukfdb/.claude/get-shit-done/workflows/execute-plan.md
@/home/ukfdb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-backend-profile-context/02-CONTEXT.md
@.planning/phases/02-backend-profile-context/02-RESEARCH.md

# Source files to modify
@app/services/job_storage.py
@app/services/cost_tracker.py
@app/services/postiz_service.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update JobStorage with profile_id support</name>
  <files>app/services/job_storage.py</files>
  <action>
Update JobStorage methods to accept and use profile_id parameter.

1. **Update create_job method signature:**
```python
def create_job(self, job_data: dict, profile_id: Optional[str] = None) -> dict:
```

Add profile_id to the Supabase insert:
```python
result = self._supabase.table("jobs").insert({
    "id": job_id,
    "job_type": job_data.get("job_type", "video_processing"),
    "status": job_data.get("status", "pending"),
    "progress": job_data.get("progress", "Queued"),
    "profile_id": profile_id,  # NEW: Add profile_id
    "data": job_data,
    "created_at": job_data["created_at"],
    "updated_at": job_data["updated_at"]
}).execute()
```

Also store profile_id in job_data for memory fallback:
```python
if profile_id:
    job_data["profile_id"] = profile_id
```

Update logging to include profile context:
```python
if profile_id:
    logger.info(f"[Profile {profile_id}] JobStorage: Created job {job_id}")
else:
    logger.info(f"JobStorage: Created job {job_id} (no profile)")
```

2. **Update list_jobs method signature:**
```python
def list_jobs(self, status: Optional[str] = None, profile_id: Optional[str] = None, limit: int = 100) -> list:
```

Add profile_id filter to Supabase query:
```python
query = self._supabase.table("jobs").select("*").order("created_at", desc=True).limit(limit)
if status:
    query = query.eq("status", status)
if profile_id:
    query = query.eq("profile_id", profile_id)  # NEW: Filter by profile
```

For memory fallback:
```python
jobs = list(self._memory_store.values())
if status:
    jobs = [j for j in jobs if j.get("status") == status]
if profile_id:
    jobs = [j for j in jobs if j.get("profile_id") == profile_id]  # NEW
```

3. **Update update_job method signature:**
```python
def update_job(self, job_id: str, updates: dict, profile_id: Optional[str] = None) -> Optional[dict]:
```

Add profile_id to Supabase update (if provided, include in update; also log with profile context):
```python
update_data = {
    "status": job.get("status"),
    "progress": job.get("progress"),
    "data": job,
    "updated_at": job["updated_at"]
}
if profile_id:
    update_data["profile_id"] = profile_id

self._supabase.table("jobs").update(update_data).eq("id", job_id).execute()

if profile_id:
    logger.debug(f"[Profile {profile_id}] JobStorage: Updated job {job_id}")
else:
    logger.debug(f"JobStorage: Updated job {job_id}")
```

IMPORTANT: All parameters are Optional with default None to maintain backward compatibility. Existing callers without profile_id will continue working.
  </action>
  <verify>
Run two checks - signature AND usage:
```bash
python -c "
from app.services.job_storage import JobStorage
import inspect

# Check signature
sig = str(inspect.signature(JobStorage.create_job))
assert 'profile_id' in sig, 'create_job missing profile_id param'

# Check actual usage in method body
import ast
source = inspect.getsource(JobStorage.create_job)
assert 'profile_id' in source, 'profile_id not used in create_job body'
print('JobStorage: signature OK, usage OK')
"
```
  </verify>
  <done>
JobStorage.create_job, update_job, and list_jobs accept profile_id parameter, store/filter it in database, and log with profile context. Parameter is actually used in method body (not just in signature).
  </done>
</task>

<task type="auto">
  <name>Task 2: Update CostTracker with profile_id support</name>
  <files>app/services/cost_tracker.py</files>
  <action>
Update CostTracker methods to accept and use profile_id parameter.

1. **Update log_elevenlabs_tts method:**
```python
def log_elevenlabs_tts(
    self,
    job_id: str,
    characters: int,
    profile_id: Optional[str] = None,  # NEW parameter
    text_preview: str = ""
) -> CostEntry:
```

Add profile_id to the CostEntry details:
```python
entry = CostEntry(
    timestamp=datetime.now().isoformat(),
    job_id=job_id,
    service="elevenlabs",
    operation="tts",
    input_units=characters,
    cost_usd=round(cost, 6),
    details={
        "profile_id": profile_id,  # NEW: Include in details
        "text_preview": text_preview[:100] + "..." if len(text_preview) > 100 else text_preview,
        "rate": f"${ELEVENLABS_COST_PER_CHAR * 1000:.2f}/1000 chars"
    }
)
```

Update _save_to_supabase to include profile_id:
```python
def _save_to_supabase(self, entry: CostEntry, profile_id: Optional[str] = None) -> bool:
    if not self._supabase:
        return False

    try:
        data = {
            "job_id": entry.job_id,
            "service": entry.service,
            "operation": entry.operation,
            "units": entry.input_units,
            "estimated_cost": entry.cost_usd,
            "profile_id": profile_id,  # NEW: Add profile_id column
            "details": entry.details
        }
        result = self._supabase.table("api_costs").insert(data).execute()
        if profile_id:
            logger.info(f"[Profile {profile_id}] Cost saved: {entry.service} - ${entry.cost_usd}")
        else:
            logger.info(f"Cost saved to Supabase: {entry.service} - ${entry.cost_usd}")
        return True
    except Exception as e:
        logger.error(f"Failed to save to Supabase: {e}")
        return False
```

Update call in log_elevenlabs_tts:
```python
self._add_entry(entry)
self._save_to_supabase(entry, profile_id=profile_id)  # Pass profile_id
if profile_id:
    logger.info(f"[Profile {profile_id}] Cost logged: ElevenLabs TTS - {characters} chars = ${cost:.4f}")
else:
    logger.info(f"Cost logged: ElevenLabs TTS - {characters} chars = ${cost:.4f}")
```

2. **Update log_gemini_analysis method:**
```python
def log_gemini_analysis(
    self,
    job_id: str,
    frames_analyzed: int,
    profile_id: Optional[str] = None,  # NEW parameter
    video_duration: float = 0
) -> CostEntry:
```

Same pattern: add profile_id to details and pass to _save_to_supabase.

3. **Update get_summary method:**
```python
def get_summary(self, profile_id: Optional[str] = None) -> Dict:
```

Update _get_summary_from_supabase to filter by profile_id if provided:
```python
def _get_summary_from_supabase(self, profile_id: Optional[str] = None) -> Dict:
    today = datetime.now().date().isoformat()

    # Get totals - filter by profile if provided
    query = self._supabase.table("api_costs").select("service, estimated_cost")
    if profile_id:
        query = query.eq("profile_id", profile_id)
    all_costs = query.execute()

    # ... rest of logic with same filter applied
```

Update _get_summary_from_local similarly to filter by profile_id in details.

IMPORTANT: profile_id=None means "all profiles" (backward compatible). When profile_id is provided, filter results to that profile only.
  </action>
  <verify>
Run two checks - signature AND usage:
```bash
python -c "
from app.services.cost_tracker import CostTracker
import inspect

# Check signature
sig = str(inspect.signature(CostTracker.log_elevenlabs_tts))
assert 'profile_id' in sig, 'log_elevenlabs_tts missing profile_id param'

# Check actual usage - profile_id should appear in method body beyond just the param
source = inspect.getsource(CostTracker.log_elevenlabs_tts)
# Should use profile_id in details dict or logging
assert source.count('profile_id') >= 2, 'profile_id not actually used in log_elevenlabs_tts'
print('CostTracker: signature OK, usage OK')
"
```
  </verify>
  <done>
CostTracker.log_elevenlabs_tts, log_gemini_analysis, and get_summary accept profile_id parameter, insert it into database, and filter results accordingly. Parameter is actually used (not just declared).
  </done>
</task>

<task type="auto">
  <name>Task 3: Update PostizPublisher with profile_id logging</name>
  <files>app/services/postiz_service.py</files>
  <action>
Update PostizPublisher methods to accept profile_id for logging purposes.

NOTE: Full per-profile Postiz credentials are Phase 5 scope. For Phase 2, we only add profile_id parameter for logging/debugging purposes.

1. **Update upload_video method:**
```python
async def upload_video(self, video_path: Path, profile_id: Optional[str] = None) -> PostizMedia:
```

Add profile context to logging:
```python
if profile_id:
    logger.info(f"[Profile {profile_id}] Uploading video to Postiz: {video_path.name} ({file_size / 1024 / 1024:.2f} MB)")
else:
    logger.info(f"Uploading video to Postiz: {video_path.name} ({file_size / 1024 / 1024:.2f} MB)")
```

And on success:
```python
if profile_id:
    logger.info(f"[Profile {profile_id}] Uploaded video to Postiz: id={media.id}")
else:
    logger.info(f"Uploaded video to Postiz: id={media.id}, path={media.path}")
```

2. **Update create_post method:**
```python
async def create_post(
    self,
    media_id: str,
    media_path: str,
    caption: str,
    integration_ids: List[str],
    schedule_date: Optional[datetime] = None,
    integrations_info: Optional[Dict[str, str]] = None,
    profile_id: Optional[str] = None  # NEW parameter
) -> PublishResult:
```

Add profile context to logging:
```python
if profile_id:
    logger.info(f"[Profile {profile_id}] Creating Postiz post for {len(integration_ids)} platforms")
else:
    logger.info(f"Creating Postiz post for {len(integration_ids)} platforms, scheduled: {schedule_date}")
```

And on success/failure:
```python
if profile_id:
    logger.info(f"[Profile {profile_id}] Created Postiz post: {data.get('id')}")
else:
    logger.info(f"Created Postiz post successfully: {data}")
```

3. **Add profile_id to get_integrations:**
```python
async def get_integrations(self, profile_id: Optional[str] = None) -> List[PostizIntegration]:
```

For logging only - the actual integrations still come from global Postiz credentials (Phase 5 will change this).

IMPORTANT: All changes are logging-only for Phase 2. The profile_id parameter is added for traceability but doesn't change Postiz credentials (that's Phase 5).
  </action>
  <verify>
Run two checks - signature AND usage:
```bash
python -c "
from app.services.postiz_service import PostizPublisher
import inspect

# Check signature
sig = str(inspect.signature(PostizPublisher.create_post))
assert 'profile_id' in sig, 'create_post missing profile_id param'

# Check actual usage - should appear in logging statements
source = inspect.getsource(PostizPublisher.create_post)
# profile_id should be used in at least one logger call
assert 'profile_id' in source and 'logger' in source, 'profile_id not used in logging in create_post'
print('PostizPublisher: signature OK, usage OK')
"
```
  </verify>
  <done>
PostizPublisher methods accept profile_id parameter and include it in log messages for per-profile debugging and traceability. Parameter is actually used in logging (not just declared).
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Import and signature check:**
   ```bash
   python -c "
   from app.services.job_storage import JobStorage
   from app.services.cost_tracker import CostTracker
   from app.services.postiz_service import PostizPublisher
   import inspect

   js_sig = str(inspect.signature(JobStorage.create_job))
   ct_sig = str(inspect.signature(CostTracker.log_elevenlabs_tts))
   pp_sig = str(inspect.signature(PostizPublisher.create_post))

   assert 'profile_id' in js_sig, 'JobStorage missing profile_id'
   assert 'profile_id' in ct_sig, 'CostTracker missing profile_id'
   assert 'profile_id' in pp_sig, 'PostizPublisher missing profile_id'
   print('All service methods have profile_id parameter')
   "
   ```

2. **Usage verification (not just signature):**
   ```bash
   grep -l '"profile_id":' app/services/job_storage.py app/services/cost_tracker.py && echo "profile_id used in database operations"
   ```

3. **Backward compatibility check:**
   ```bash
   python -c "
   from app.services.job_storage import get_job_storage
   from app.services.cost_tracker import get_cost_tracker

   # These should work without profile_id (backward compatible)
   js = get_job_storage()
   ct = get_cost_tracker()
   print('Singleton services instantiate OK')
   "
   ```
</verification>

<success_criteria>
- JobStorage.create_job, update_job, list_jobs accept profile_id parameter AND use it in database operations
- CostTracker.log_elevenlabs_tts, log_gemini_analysis, get_summary accept profile_id parameter AND use it
- PostizPublisher.upload_video, create_post, get_integrations accept profile_id parameter AND use it in logging
- All parameters are Optional with None default (backward compatible)
- profile_id is stored in Supabase inserts for jobs and api_costs tables
- Logging includes [Profile {id}] prefix when profile_id provided
</success_criteria>

<output>
After completion, create `.planning/phases/02-backend-profile-context/02-02-SUMMARY.md`
</output>
