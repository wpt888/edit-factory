---
phase: 08-audio-normalization
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - app/api/library_routes.py
autonomous: false

must_haves:
  truths:
    - "Rendered videos have audio normalized to -14 LUFS"
    - "Audio has true peak limiting at -1.5 dBTP (no clipping)"
    - "Two-pass normalization used (measure then apply)"
    - "Normalization applies to concatenated audio (not per-segment)"
    - "Normalization failure degrades gracefully (render continues without normalization)"
  artifacts:
    - path: "app/api/library_routes.py"
      provides: "_render_with_preset with audio normalization integration"
      contains: "measure_loudness"
  key_links:
    - from: "app/api/library_routes.py"
      to: "app/services/audio_normalizer.py"
      via: "import and call measure_loudness, build_loudnorm_filter"
      pattern: "from app\\.services\\.audio_normalizer import"
    - from: "_render_with_preset"
      to: "FFmpeg -af parameter"
      via: "loudnorm filter string in audio_filters list"
      pattern: "audio_filters\\.append.*loudnorm"
---

<objective>
Integrate two-pass audio normalization into the video render pipeline.

Purpose: Wire up the audio_normalizer service into _render_with_preset() so all exported videos automatically get -14 LUFS loudness normalization. This ensures consistent perceived volume across all Edit Factory outputs, matching social media platform standards.

Output: _render_with_preset() performs two-pass loudnorm when audio is present, with graceful fallback on measurement failure.
</objective>

<execution_context>
@/home/ukfdb/.claude/get-shit-done/workflows/execute-plan.md
@/home/ukfdb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-audio-normalization/08-RESEARCH.md
@.planning/phases/08-audio-normalization/08-01-SUMMARY.md
@app/api/library_routes.py (lines 2317-2449 for _render_with_preset)
@app/services/audio_normalizer.py
@app/services/encoding_presets.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate audio normalization into render pipeline</name>
  <files>app/api/library_routes.py</files>
  <action>
Modify app/api/library_routes.py to add two-pass audio normalization:

1. **Add import at top of file** (with other service imports):
   ```python
   from app.services.audio_normalizer import measure_loudness, build_loudnorm_filter
   ```

2. **Modify _render_with_preset() function** to add audio normalization after video filters but before encoding:

   After the existing filter building (around line 2376 after `if filters: cmd.extend(["-vf", ",".join(filters)])`), add audio normalization logic:

   ```python
   # Audio normalization (two-pass loudnorm)
   audio_filters = []

   if has_audio and audio_path:  # Only normalize real audio, not silent
       if encoding_preset.normalize_audio:
           logger.info(f"Performing two-pass audio normalization (target: {encoding_preset.target_lufs} LUFS)")

           # First pass: Measure loudness
           measurement = measure_loudness(
               audio_path,
               target_lufs=encoding_preset.target_lufs,
               target_tp=encoding_preset.target_tp,
               target_lra=encoding_preset.target_lra
           )

           if measurement:
               # Second pass: Build normalization filter
               loudnorm_filter = build_loudnorm_filter(
                   measurement,
                   target_lufs=encoding_preset.target_lufs,
                   target_tp=encoding_preset.target_tp,
                   target_lra=encoding_preset.target_lra
               )
               audio_filters.append(loudnorm_filter)
               logger.info(f"Audio normalization: {measurement.input_i:.1f} LUFS -> {encoding_preset.target_lufs} LUFS")
           else:
               logger.warning("Audio normalization measurement failed, rendering without normalization")

   # Apply audio filters if any
   if audio_filters:
       cmd.extend(["-af", ",".join(audio_filters)])
   ```

3. **Important placement**: The audio_filters section must come:
   - AFTER the video filter section (`if filters: cmd.extend(["-vf", ...])`)
   - BEFORE the FPS setting (`cmd.extend(["-r", str(preset.get("fps", 30))])`)
   - BEFORE the encoding parameters (`cmd.extend(encoding_params)`)

4. **Verify sample rate handling**: The encoding_preset.to_ffmpeg_params() already includes `-ar 48000` which prevents the 192kHz upsampling issue.

Key patterns to follow:
- Use existing logger instance (already defined in file)
- Follow graceful degradation (render without normalization if measurement fails)
- Only normalize real audio (has_audio=True and audio_path exists), skip for silent audio (anullsrc)
  </action>
  <verify>
Run: `grep -n "measure_loudness\|audio_filters\|loudnorm" app/api/library_routes.py | head -20`
Expected: Shows import line and audio_filters usage in _render_with_preset
  </verify>
  <done>_render_with_preset() calls measure_loudness() and build_loudnorm_filter() for audio normalization when audio is present</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Two-pass audio normalization integrated into video render pipeline. All exported videos should now have consistent -14 LUFS loudness.</what-built>
  <how-to-verify>
1. Start the development server:
   ```bash
   cd "/mnt/c/OBSID SRL/n8n/edit_factory"
   ./start-dev.sh
   ```

2. Open http://localhost:3000/library in browser

3. Create or select a project with video content

4. Generate a clip with audio (TTS or source audio)

5. Render the clip using any platform preset (TikTok, Reels, YouTube Shorts)

6. Check the terminal output for log messages:
   - "Performing two-pass audio normalization (target: -14.0 LUFS)"
   - "Measured: Loudness: X.X LUFS, Peak: X.X dBTP, LRA: X.X LU"
   - "Audio normalization: X.X LUFS -> -14.0 LUFS"

7. (Optional) Verify output audio levels with ffmpeg:
   ```bash
   ffmpeg -i [output_video.mp4] -af loudnorm=print_format=json -f null - 2>&1 | grep -A10 "input_i"
   ```
   Expected: input_i should be close to -14.0 LUFS

Expected behavior:
- Videos with audio show normalization logs
- Videos without audio (silent) skip normalization
- If normalization fails, render continues (graceful degradation)
  </how-to-verify>
  <resume-signal>Type "approved" if audio normalization works correctly, or describe any issues observed</resume-signal>
</task>

</tasks>

<verification>
1. Import check: `python -c "from app.api.library_routes import router; print('Router imports OK')"`
2. Code check: `grep -c "measure_loudness" app/api/library_routes.py` (should return 2: import + call)
3. Audio filter check: `grep -c "audio_filters" app/api/library_routes.py` (should return 3+)
</verification>

<success_criteria>
- _render_with_preset() integrates two-pass loudnorm normalization
- Audio normalized to -14 LUFS for all platform presets
- True peak limited to -1.5 dBTP (via loudnorm filter)
- Graceful degradation if measurement fails
- Silent audio (anullsrc) skipped for normalization
- User verification confirms consistent audio levels in exported videos
</success_criteria>

<output>
After completion, create `.planning/phases/08-audio-normalization/08-02-SUMMARY.md`
</output>
