---
phase: 19-product-browser
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/api/product_routes.py
  - app/api/feed_routes.py
  - app/main.py
autonomous: true
requirements:
  - FEED-02
  - FEED-03
  - FEED-04
  - FEED-05
  - FEED-06

must_haves:
  truths:
    - "GET /feeds/{feed_id}/products returns paginated products with search, on_sale, category, and brand filter params"
    - "GET /feeds/{feed_id}/products/filters returns distinct brand and category values for dropdown population"
    - "Filtered queries return accurate total count (not unfiltered product_count)"
    - "Old list_products in feed_routes.py is removed — no route conflict"
  artifacts:
    - path: "app/api/product_routes.py"
      provides: "Product listing with filters + filter options endpoint"
      contains: "ilike"
    - path: "app/main.py"
      provides: "product_router mounted at /api/v1"
      contains: "product_routes"
  key_links:
    - from: "app/api/product_routes.py"
      to: "supabase products table"
      via: "ilike, eq, range queries"
      pattern: "ilike.*title"
    - from: "app/main.py"
      to: "app/api/product_routes.py"
      via: "include_router"
      pattern: "product_router"
---

<objective>
Create product_routes.py with filtered, paginated product listing and a filter-options endpoint for dropdown population. Move the existing list_products from feed_routes.py into product_routes.py with four new filter params (search, on_sale, category, brand) and accurate filtered count via Supabase count="exact".

Purpose: Backend API needed before the frontend product browser can be built (19-02 depends on these endpoints).
Output: product_routes.py with two endpoints, feed_routes.py cleaned up, main.py updated.
</objective>

<execution_context>
@/home/ukfdb/.claude/get-shit-done/workflows/execute-plan.md
@/home/ukfdb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-product-browser/19-RESEARCH.md
@app/api/feed_routes.py
@app/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create product_routes.py with filtered product listing and filters endpoint</name>
  <files>app/api/product_routes.py, app/api/feed_routes.py, app/main.py</files>
  <action>
Create `app/api/product_routes.py` as a new router file:

1. **Router setup:**
   - `router = APIRouter(prefix="/feeds", tags=["Products"])`
   - Import `_get_supabase` from feed_routes (or duplicate the helper — it's 3 lines)
   - Import `ProfileContext, get_profile_context` from `app.api.auth`

2. **GET /{feed_id}/products endpoint** — move from feed_routes.py and extend:
   - Keep existing params: `feed_id: str`, `page: int = 1`, `page_size: int = 50`
   - Add four optional filter params:
     - `search: Optional[str] = None` — if provided, apply `.ilike("title", f"%{search}%")`
     - `on_sale: Optional[bool] = None` — if True, apply `.eq("is_on_sale", True)`
     - `category: Optional[str] = None` — if provided, apply `.eq("product_type", category)`
     - `brand: Optional[str] = None` — if provided, apply `.eq("brand", brand)`
   - Still verify feed ownership via profile_id check
   - Clamp page_size to max 200, page to min 1
   - Build the query by chaining filters conditionally (see Research Pattern 1)
   - **Total count:** When ANY filter is active, use a separate count query with `.select("id", count="exact")` and the same filters applied, then use `count_result.count` for `total`. When no filters are active, use the stored `product_count` from the feed row (cheaper). This avoids Pitfall 2 from research.
   - Return same shape: `{ products: [...], pagination: { page, page_size, total, total_pages } }`

3. **GET /{feed_id}/products/filters endpoint:**
   - Verify feed ownership (same pattern)
   - Fetch all brand values: `supabase.table("products").select("brand").eq("feed_id", feed_id).execute()`
   - Fetch all product_type values: `supabase.table("products").select("product_type").eq("feed_id", feed_id).execute()`
   - Deduplicate in Python: `sorted(set(r["brand"] for r in brands_result.data if r.get("brand")))`
   - Return `{ brands: [...], categories: [...] }`

4. **Remove list_products from feed_routes.py:**
   - Delete the `@router.get("/{feed_id}/products")` endpoint and its docstring from feed_routes.py
   - Keep all other feed endpoints (CRUD + sync) untouched

5. **Mount in main.py:**
   - Add import: `from app.api.product_routes import router as product_router`
   - Add: `app.include_router(product_router, prefix="/api/v1", tags=["Products"])`
   - Place it AFTER the feed_router line to keep imports organized

6. **Duplicate _get_supabase in product_routes.py** rather than importing from feed_routes — keeps the file self-contained (same 3-line pattern used across all route files).
  </action>
  <verify>
Run the backend server: `python run.py`
Then test endpoints with curl:

```bash
# List products with no filters (should return paginated results)
curl "http://localhost:8000/api/v1/feeds/{FEED_ID}/products?page=1&page_size=5" -H "X-Profile-Id: {PROFILE_ID}"

# Search by title
curl "http://localhost:8000/api/v1/feeds/{FEED_ID}/products?search=pantofi" -H "X-Profile-Id: {PROFILE_ID}"

# Filter on-sale only
curl "http://localhost:8000/api/v1/feeds/{FEED_ID}/products?on_sale=true" -H "X-Profile-Id: {PROFILE_ID}"

# Get filter options
curl "http://localhost:8000/api/v1/feeds/{FEED_ID}/products/filters" -H "X-Profile-Id: {PROFILE_ID}"

# Verify old endpoint removed — feed_routes should NOT have list_products
grep -c "list_products" app/api/feed_routes.py  # should be 0
```
  </verify>
  <done>
Both endpoints respond correctly: /products returns filtered+paginated products with accurate total count, /products/filters returns distinct brands and categories. No route conflict — old endpoint removed from feed_routes.py.
  </done>
</task>

</tasks>

<verification>
- `python -c "from app.api.product_routes import router; print('OK')"` imports without error
- `grep "list_products" app/api/feed_routes.py` returns nothing (endpoint moved)
- `grep "product_router" app/main.py` confirms router is mounted
- API docs at /docs show both new endpoints under "Products" tag
</verification>

<success_criteria>
- product_routes.py exists with GET /{feed_id}/products (4 filter params) and GET /{feed_id}/products/filters
- feed_routes.py no longer has list_products endpoint
- main.py mounts product_router
- Filtered queries return accurate total count
- Filter options endpoint returns sorted distinct brands and categories (NULLs excluded)
</success_criteria>

<output>
After completion, create `.planning/phases/19-product-browser/19-01-SUMMARY.md`
</output>
