---
phase: 30-frontend-error-handling-adoption
plan: 03
type: execute
wave: 2
depends_on: [30-01, 30-02]
files_modified:
  - frontend/src/app/product-video/page.tsx
  - frontend/src/app/products/page.tsx
  - frontend/src/app/scripts/page.tsx
  - frontend/src/app/librarie/page.tsx
  - frontend/src/app/tts-library/page.tsx
  - frontend/src/app/settings/page.tsx
  - frontend/src/app/library/page.tsx
  - frontend/src/contexts/profile-context.tsx
autonomous: true
requirements: [FE-02]
gap_closure: true

must_haves:
  truths:
    - "All polling and data-fetch GET calls use apiGetWithRetry() instead of raw apiGet()"
    - "At least 3 page sections are wrapped with ErrorBoundary for section-level error isolation"
    - "The error → boundary → handleApiError → toast E2E flow works end-to-end"
  artifacts:
    - path: "frontend/src/app/library/page.tsx"
      provides: "ErrorBoundary wrapping around major page sections"
      contains: "ErrorBoundary"
    - path: "frontend/src/app/products/page.tsx"
      provides: "apiGetWithRetry for data fetching"
      contains: "apiGetWithRetry"
    - path: "frontend/src/app/scripts/page.tsx"
      provides: "apiGetWithRetry for data fetching"
      contains: "apiGetWithRetry"
  key_links:
    - from: "page files"
      to: "frontend/src/lib/api.ts"
      via: "import { apiGetWithRetry } from '@/lib/api'"
      pattern: "apiGetWithRetry"
    - from: "frontend/src/app/library/page.tsx"
      to: "frontend/src/components/error-boundary.tsx"
      via: "import { ErrorBoundary } from '@/components/error-boundary'"
      pattern: "ErrorBoundary"
---

<objective>
Adopt apiGetWithRetry() for all data-fetch GET calls and wrap 3+ page sections with ErrorBoundary for section-level error isolation. This completes the FE-02 gap closure.

Purpose: Wire the remaining 2 orphaned Phase 26 exports (apiGetWithRetry, ErrorBoundary) into actual usage. Combined with Plans 01+02, this satisfies all 5 success criteria for Phase 30.
Output: apiGetWithRetry used in all pages with apiGet data fetching, ErrorBoundary wrapping 3+ page sections.
</objective>

<execution_context>
@/home/ukfdb/.claude/get-shit-done/workflows/execute-plan.md
@/home/ukfdb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@frontend/src/lib/api.ts
@frontend/src/components/error-boundary.tsx
@.planning/phases/30-frontend-error-handling-adoption/30-01-SUMMARY.md
@.planning/phases/30-frontend-error-handling-adoption/30-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace apiGet with apiGetWithRetry for all data-fetch GET calls</name>
  <files>
    frontend/src/app/product-video/page.tsx
    frontend/src/app/products/page.tsx
    frontend/src/app/scripts/page.tsx
    frontend/src/app/librarie/page.tsx
    frontend/src/app/tts-library/page.tsx
    frontend/src/app/settings/page.tsx
    frontend/src/contexts/profile-context.tsx
  </files>
  <action>
For each file that currently imports and uses `apiGet`:
1. Change the import from `apiGet` to `apiGetWithRetry` in the import statement from `@/lib/api`.
2. Replace all `apiGet(...)` calls with `apiGetWithRetry(...)`. The signature is identical — `apiGetWithRetry(endpoint, options?)` — so no other changes needed.
3. `apiGetWithRetry` retries up to 2 times on transient errors (5xx, network) with 1-second delay. It does NOT retry on 4xx client errors. This is safe for all data-fetch GET calls.

**Files currently using apiGet (from grep):**
- `product-video/page.tsx` — product data fetching
- `products/page.tsx` — product list fetching
- `scripts/page.tsx` — script list fetching
- `librarie/page.tsx` — library data fetching
- `tts-library/page.tsx` — TTS library fetching
- `settings/page.tsx` — settings loading
- `profile-context.tsx` — profile fetching

**Do NOT change:**
- `apiGet` calls inside `usePolling` hooks — the polling hook has its own retry logic
- Any `apiGet` calls in `api.ts` itself (apiGetWithRetry delegates to apiGet internally)
- POST/PUT/DELETE calls — only GET calls should use the retry wrapper

**If a file imports both `apiGet` and other api functions:** Only replace `apiGet` with `apiGetWithRetry` in the import, keep other imports unchanged.
  </action>
  <verify>
Run: `grep -rn "apiGet(" frontend/src/app/ frontend/src/contexts/ --include="*.tsx" --include="*.ts" | grep -v "apiGetWithRetry" | grep -v "node_modules" | grep -v "api.ts"` — should return zero matches (all apiGet replaced with apiGetWithRetry except in api.ts itself).
Run: `grep -c "apiGetWithRetry" frontend/src/app/products/page.tsx frontend/src/app/scripts/page.tsx frontend/src/app/librarie/page.tsx` — each should be >= 1.
  </verify>
  <done>
All data-fetch GET calls across 7 files use apiGetWithRetry() instead of raw apiGet(). Transient failures now automatically retry with exponential backoff.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wrap 3+ page sections with ErrorBoundary for section-level error isolation</name>
  <files>
    frontend/src/app/library/page.tsx
  </files>
  <action>
Import `ErrorBoundary` from `@/components/error-boundary` in library/page.tsx.

Wrap at least 3 major page sections with `<ErrorBoundary>`:

1. **Clip Gallery section** — Wrap the clip gallery/grid rendering area. If one clip card throws, the rest of the page still works.
   ```tsx
   <ErrorBoundary>
     {/* existing clip gallery JSX */}
   </ErrorBoundary>
   ```

2. **Render Dialog section** — Wrap the render configuration dialog/modal area. If render settings throw, the gallery remains usable.
   ```tsx
   <ErrorBoundary>
     {/* existing render dialog JSX */}
   </ErrorBoundary>
   ```

3. **Segment Selection Modal** — Wrap the segment selection modal. If segment selection crashes, the main page remains functional.
   ```tsx
   <ErrorBoundary>
     {/* existing segment selection modal JSX */}
   </ErrorBoundary>
   ```

The ErrorBoundary component already has:
- A fallback UI with "A aparut o eroare" message and "Reincearca" button
- A handleReset method that clears the error state
- Support for custom fallback and onError props

**Do NOT:**
- Wrap the entire page in a single ErrorBoundary (that's what global-error.tsx does)
- Wrap tiny elements (buttons, inputs) — only wrap logical sections
- Add ErrorBoundary to every page — library/page.tsx is the most complex page and benefits most

**Optional:** If there are other major pages (assembly, pipeline) that have distinct sections, add ErrorBoundary there too, but the minimum is 3 sections in library/page.tsx.
  </action>
  <verify>
Run: `grep -c "ErrorBoundary" frontend/src/app/library/page.tsx` — should be >= 6 (3 opening + 3 closing tags).
Run: `grep "import.*ErrorBoundary" frontend/src/app/library/page.tsx` — should show the import.
Run: `cd frontend && npx next build 2>&1 | tail -5` — should compile without errors.
  </verify>
  <done>
At least 3 page sections in library/page.tsx are wrapped with ErrorBoundary. Section-level errors show a friendly fallback UI with "Reincearca" button instead of crashing the entire page.
  </done>
</task>

</tasks>

<verification>
1. `grep -rn "apiGet(" frontend/src/app/ frontend/src/contexts/ --include="*.tsx" --include="*.ts" | grep -v "apiGetWithRetry" | grep -v "api.ts"` — zero matches
2. `grep -c "ErrorBoundary" frontend/src/app/library/page.tsx` — >= 6
3. Full frontend build: `cd frontend && npx next build 2>&1 | tail -10` — exits with success
4. Combined check (all 5 success criteria):
   - SC1: `grep -rn "console.error" frontend/src/app/ frontend/src/components/ frontend/src/hooks/ frontend/src/contexts/ | grep -v "error-boundary\|global-error\|auth-provider"` — zero
   - SC2: `grep -rn "alert(" frontend/src/app/ frontend/src/components/` — zero
   - SC3: No raw `apiGet(` in pages (verified above)
   - SC4: `grep -c "ErrorBoundary" frontend/src/app/library/page.tsx` — >= 6
   - SC5: ErrorBoundary imports handleApiError flow verified by build success
</verification>

<success_criteria>
- All data-fetch apiGet() calls replaced with apiGetWithRetry() across 7 files
- At least 3 page sections wrapped with ErrorBoundary in library/page.tsx
- Frontend compiles without TypeScript errors
- All 5 Phase 30 success criteria met (zero console.error in catch blocks, zero alert, apiGetWithRetry adopted, ErrorBoundary wired, E2E flow works)
</success_criteria>

<output>
After completion, create `.planning/phases/30-frontend-error-handling-adoption/30-03-SUMMARY.md`
</output>
