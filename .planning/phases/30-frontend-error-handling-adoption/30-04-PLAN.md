---
phase: 30-frontend-error-handling-adoption
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/app/segments/page.tsx
autonomous: true
requirements: [FE-02]
gap_closure: true

must_haves:
  truths:
    - "Zero console.error() calls remain in catch blocks in segments/page.tsx"
    - "All data-fetch GET calls in segments/page.tsx use apiGetWithRetry() instead of raw apiGet()"
    - "API errors on the segments page surface as sonner toasts via handleApiError()"
  artifacts:
    - path: "frontend/src/app/segments/page.tsx"
      provides: "handleApiError in all 12 catch blocks + apiGetWithRetry for 3 data-fetch calls"
      contains: "handleApiError"
  key_links:
    - from: "frontend/src/app/segments/page.tsx"
      to: "frontend/src/lib/api-error.ts"
      via: "import { handleApiError, apiGetWithRetry } from '@/lib/api'"
      pattern: "handleApiError"
---

<objective>
Replace all 12 console.error() calls in catch blocks and 3 raw apiGet() data-fetch calls in segments/page.tsx with handleApiError() and apiGetWithRetry() respectively.

Purpose: Close the last FE-02 gap — segments/page.tsx was missed by Plans 01-03. ROADMAP SC1 requires "all pages" have zero console.error in catch blocks; SC3 requires apiGetWithRetry for all data-fetch GET calls.
Output: segments/page.tsx fully migrated to consistent error handling pattern.
</objective>

<execution_context>
@/home/ukfdb/.claude/get-shit-done/workflows/execute-plan.md
@/home/ukfdb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@frontend/src/lib/api-error.ts
@frontend/src/lib/api.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace console.error with handleApiError and apiGet with apiGetWithRetry in segments/page.tsx</name>
  <files>frontend/src/app/segments/page.tsx</files>
  <action>
**Step 1: Update imports (line 52)**

Change the import from:
```
import { apiGet, apiPost, apiPatch, apiPut, apiDelete, API_URL } from "@/lib/api";
```
to:
```
import { apiGetWithRetry, apiPost, apiPatch, apiPut, apiDelete, handleApiError, API_URL } from "@/lib/api";
```

Note: `apiGet` is removed entirely since all 3 usages are data-fetch calls that should use `apiGetWithRetry`. The `handleApiError` import is added.

**Step 2: Replace 3 apiGet() calls with apiGetWithRetry()**

- Line 183 (`fetchSourceVideos`): `apiGet("/segments/source-videos")` -> `apiGetWithRetry("/segments/source-videos")`
- Line 197 (`fetchSegments`): `apiGet(\`/segments/source-videos/${videoId}/segments\`)` -> `apiGetWithRetry(\`/segments/source-videos/${videoId}/segments\`)`
- Line 212 (`fetchAllSegments`): `apiGet("/segments")` -> `apiGetWithRetry("/segments")`

**Step 3: Replace 12 console.error() calls with handleApiError()**

Replace each `console.error(...)` in a catch block with `handleApiError(error, "context message")`. Keep any state cleanup code (setLoading, setUploadError, etc.) — handleApiError only handles the toast.

Specific replacements:

1. Line 189 (`fetchSourceVideos` catch): `console.error("Failed to fetch source videos:", error)` -> `handleApiError(error, "Eroare la incarcarea video-urilor sursa")`

2. Line 203 (`fetchSegments` catch): `console.error("Failed to fetch segments:", error)` -> `handleApiError(error, "Eroare la incarcarea segmentelor")`

3. Line 218 (`fetchAllSegments` catch): `console.error("Failed to fetch all segments:", error)` -> `handleApiError(error, "Eroare la incarcarea tuturor segmentelor")`

4. Line 287 (`handleDeleteSegment` else branch): `console.error("Delete segment failed:", res.status, await res.text().catch(() => ""))` — This is inside an `if (res.ok) {} else {}` block, not a catch block. However, since apiFetch now throws on non-2xx (ApiError), this else branch is dead code for apiDelete calls. Remove the else branch entirely — apiFetch already throws, so the catch block handles errors.

5. Line 290 (`handleDeleteSegment` catch): `console.error("Failed to delete segment:", error)` -> `handleApiError(error, "Eroare la stergerea segmentului")`

6. Line 362 (`handleUpload` catch): `console.error("Failed to upload video:", error)` -> `handleApiError(error, "Eroare la incarcarea video-ului")`. Note: keep the `setUploadError(...)` line below it — that sets inline error state for the upload dialog.

7. Line 389 (`handleDeleteVideo` catch): `console.error("Failed to delete video:", error)` -> `handleApiError(error, "Eroare la stergerea video-ului")`

8. Line 432 (`handleMergeSegments` loop catch): `console.error("Failed to delete segment:", error)` -> `handleApiError(error, "Eroare la stergerea segmentului in unire")`

9. Line 500 (`handleSaveSegment` catch): `console.error("Failed to create segment:", error)` -> `handleApiError(error, "Eroare la crearea segmentului")`

10. Line 524 (`handleUpdateSegment` catch): `console.error("Failed to update segment:", error)` -> `handleApiError(error, "Eroare la actualizarea segmentului")`

11. Line 567 (`handleSaveTransforms` catch): `console.error("Failed to save transforms:", error)` -> `handleApiError(error, "Eroare la salvarea transformarilor")`

12. Line 591 (`handleToggleFavorite` catch): `console.error("Failed to toggle favorite:", error)` -> `handleApiError(error, "Eroare la modificarea favoritului")`

**Important notes:**
- The `handleUpload` function at line 340 uses raw `fetch()` (not apiGet) for FormData upload — do NOT change this to apiGetWithRetry. It's a POST upload, not a GET data-fetch. But DO replace its console.error (line 362) with handleApiError.
- The `else` branch at line 287 (`handleDeleteSegment`) can be removed because `apiDelete` calls `apiFetch` which throws `ApiError` on non-2xx — the response will never reach the else branch. If you prefer safety, convert it to: `handleApiError(new Error(\`Delete failed: ${res.status}\`), "Eroare la stergerea segmentului")` instead of removing.
- Keep ALL state cleanup code (setLoadingSegments(false), setUploadingVideo(false), setUploadError, etc.) — these are in `finally` blocks or after the handleApiError call.
  </action>
  <verify>
Run: `cd "/mnt/c/OBSID SRL/n8n/edit_factory" && grep -c "console.error" frontend/src/app/segments/page.tsx` — should return 0.
Run: `cd "/mnt/c/OBSID SRL/n8n/edit_factory" && grep -c "handleApiError" frontend/src/app/segments/page.tsx` — should be >= 12.
Run: `cd "/mnt/c/OBSID SRL/n8n/edit_factory" && grep -c "apiGetWithRetry" frontend/src/app/segments/page.tsx` — should be 3.
Run: `cd "/mnt/c/OBSID SRL/n8n/edit_factory" && grep "apiGet[^W]" frontend/src/app/segments/page.tsx` — should return nothing (no raw apiGet remaining).
Run: `cd "/mnt/c/OBSID SRL/n8n/edit_factory/frontend" && npx next lint --no-cache 2>&1 | head -20` — no errors.
  </verify>
  <done>
Zero console.error() calls in segments/page.tsx catch blocks. All 3 data-fetch GET calls use apiGetWithRetry(). All API errors surface as sonner toasts via handleApiError(). ROADMAP SC1 and SC3 now fully satisfied across all pages.
  </done>
</task>

</tasks>

<verification>
1. `grep -rn "console.error" frontend/src/app/segments/page.tsx` — zero matches
2. `grep -c "handleApiError" frontend/src/app/segments/page.tsx` — >= 12
3. `grep -c "apiGetWithRetry" frontend/src/app/segments/page.tsx` — exactly 3
4. `grep "apiGet[^W]" frontend/src/app/segments/page.tsx` — no raw apiGet calls
5. Full sweep confirms ROADMAP SC1: `grep -rn "console.error" frontend/src/app/ --include="*.tsx" | grep -v "error-boundary" | grep -v "global-error" | grep -v "auth-provider"` — zero matches
6. Frontend builds: `cd frontend && npx next build 2>&1 | tail -5`
</verification>

<success_criteria>
- Zero console.error() in catch blocks in segments/page.tsx
- handleApiError() imported and called in all 12 former console.error locations
- apiGetWithRetry() used for all 3 data-fetch GET calls (fetchSourceVideos, fetchSegments, fetchAllSegments)
- No raw apiGet() calls remain in the file
- Frontend compiles without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/30-frontend-error-handling-adoption/30-04-SUMMARY.md`
</output>
