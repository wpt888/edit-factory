---
phase: 01-database-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/002_create_profiles_table.sql
  - supabase/migrations/003_add_profile_id_to_tables.sql
  - supabase/migrations/004_backfill_default_profiles.sql
  - supabase/migrations/005_enforce_constraints_and_rls.sql
autonomous: false

must_haves:
  truths:
    - "Profiles table exists with id, user_id, name, description, is_default, TTS/Postiz settings columns"
    - "editai_projects has profile_id column with NOT NULL constraint and FK to profiles"
    - "A default profile exists for each user that had projects"
    - "All existing projects are assigned to their user's default profile"
    - "RLS policies on editai_projects filter by profile_id (not just user_id)"
    - "All profile_id columns have indexes for RLS performance"
  artifacts:
    - path: "supabase/migrations/002_create_profiles_table.sql"
      provides: "Profiles table with RLS policies"
    - path: "supabase/migrations/003_add_profile_id_to_tables.sql"
      provides: "Nullable profile_id columns with NOT VALID FKs and indexes"
    - path: "supabase/migrations/004_backfill_default_profiles.sql"
      provides: "Default profile creation and data backfill"
    - path: "supabase/migrations/005_enforce_constraints_and_rls.sql"
      provides: "NOT NULL enforcement and profile-aware RLS policies"
  key_links:
    - from: "profiles.id"
      to: "editai_projects.profile_id"
      via: "foreign key with CASCADE delete"
    - from: "editai_projects.profile_id"
      to: "RLS policies"
      via: "profile_id IN (SELECT id FROM profiles WHERE user_id = auth.uid())"
---

<objective>
Create and apply SQL migrations to add profile-based data isolation to the Supabase database.

Purpose: Establish the database foundation for multi-profile support. This enables Phase 2 (backend) and Phase 3 (frontend) to build profile switching on top of a correctly isolated data layer.

Output: Four SQL migration files (002-005) applied to the live Supabase database, with profiles table created, profile_id added to projects, existing data migrated to a default profile, and profile-aware RLS policies active.
</objective>

<execution_context>
@/home/ukfdb/.claude/get-shit-done/workflows/execute-plan.md
@/home/ukfdb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-database-foundation/01-RESEARCH.md
@supabase/migrations/001_add_auth_and_rls.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write SQL migration files 002-005</name>
  <files>
    supabase/migrations/002_create_profiles_table.sql
    supabase/migrations/003_add_profile_id_to_tables.sql
    supabase/migrations/004_backfill_default_profiles.sql
    supabase/migrations/005_enforce_constraints_and_rls.sql
  </files>
  <action>
Create four SQL migration files following the research patterns. Each file is designed to be run sequentially in Supabase Dashboard SQL Editor (not via Supabase CLI, since migrations are applied manually to the remote instance).

**Migration 002: Create profiles table**

Create `public.profiles` table with these columns:
- `id` UUID PRIMARY KEY DEFAULT gen_random_uuid()
- `user_id` UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE
- `name` TEXT NOT NULL
- `description` TEXT
- `default_tts_provider` TEXT DEFAULT 'elevenlabs' CHECK (value IN ('elevenlabs', 'edge'))
- `elevenlabs_voice_id` TEXT
- `edge_tts_voice` TEXT
- `tts_model` TEXT
- `postiz_integration_ids` JSONB DEFAULT '[]'
- `default_caption_template` TEXT
- `is_default` BOOLEAN DEFAULT false
- `created_at` TIMESTAMPTZ DEFAULT NOW()
- `updated_at` TIMESTAMPTZ DEFAULT NOW()

Add indexes:
- `idx_profiles_user_id` on (user_id)
- Unique partial index `idx_profiles_user_default` on (user_id) WHERE (is_default = true)

Enable RLS and create CRUD policies (SELECT/INSERT/UPDATE/DELETE) for `authenticated` role using `(SELECT auth.uid()) = user_id` pattern (optimized wrapper).

Add service role bypass policy matching the pattern in migration 001.

Add `handle_updated_at()` trigger function (CREATE OR REPLACE) and attach to profiles table.

**Migration 003: Add profile_id to existing tables**

Add nullable `profile_id UUID` column to:
- `editai_projects` - FK to profiles(id) ON DELETE CASCADE, NOT VALID
- `jobs` - FK to profiles(id) ON DELETE SET NULL, NOT VALID (jobs may not have user context)
- `api_costs` - FK to profiles(id) ON DELETE SET NULL, NOT VALID (costs may not have user context)

IMPORTANT: Use `IF NOT EXISTS` pattern for columns (via DO block checking information_schema) so migrations are idempotent.

Create indexes BEFORE any later RLS changes:
- `idx_projects_profile_id` on editai_projects(profile_id)
- `idx_projects_user_profile` on editai_projects(user_id, profile_id)
- `idx_jobs_profile_id` on jobs(profile_id)
- `idx_costs_profile_id` on api_costs(profile_id)

Do NOT touch editai_clips, editai_clip_content, or editai_project_segments - they inherit profile context through their project_id FK to editai_projects.

**Migration 004: Backfill default profiles**

Step 1: Create default profile for each user that has projects:
```sql
INSERT INTO profiles (user_id, name, description, is_default)
SELECT DISTINCT user_id, 'Default Profile', 'Auto-created during profile migration', true
FROM editai_projects WHERE user_id IS NOT NULL
ON CONFLICT (user_id) WHERE (is_default = true) DO NOTHING;
```

Step 2: Backfill editai_projects.profile_id from the default profile matching user_id.

Step 3: Attempt backfill of jobs.profile_id using data->>'user_id' JSONB field (if present). Do not fail if no matches found.

Step 4: Attempt backfill of api_costs.profile_id using metadata->>'user_id' JSONB field (if present). Do not fail if no matches found.

Step 5: Verification block (DO $$ ... END $$) that raises EXCEPTION if any projects with user_id still have NULL profile_id. Use RAISE NOTICE for success.

**Migration 005: Enforce constraints and update RLS**

Part 1 - Validate NOT VALID foreign keys:
```sql
ALTER TABLE editai_projects VALIDATE CONSTRAINT fk_projects_profile_id;
ALTER TABLE jobs VALIDATE CONSTRAINT fk_jobs_profile_id;
ALTER TABLE api_costs VALIDATE CONSTRAINT fk_costs_profile_id;
```

Part 2 - Make profile_id NOT NULL on editai_projects ONLY (not jobs/api_costs):
Use the zero-downtime pattern: ADD CHECK NOT VALID -> VALIDATE -> SET NOT NULL -> DROP CHECK. Four separate statements, NOT combined.

Part 3 - Replace existing user-only RLS policies with profile-aware policies:
Wrap in BEGIN...COMMIT transaction. For each table:

editai_projects: Drop old policies (from migration 001), create new ones filtering by `profile_id IN (SELECT id FROM profiles WHERE user_id = (SELECT auth.uid()))`. Keep service role bypass.

editai_clips: Drop old policies, create new ones using EXISTS join through editai_projects -> profiles with `(SELECT auth.uid())` wrapper. Keep service role bypass.

editai_clip_content: Drop old policies, create new ones using EXISTS join through editai_clips -> editai_projects -> profiles. Keep service role bypass.

editai_project_segments: Drop old policies, create new ones using EXISTS join through editai_projects -> profiles. Keep service role bypass.

Part 4 - Verification DO block checking: indexes exist, constraints exist, RLS enabled, policies exist.

CRITICAL RULES from research:
- Use `(SELECT auth.uid())` wrapper everywhere (95% perf improvement)
- RLS enable + policies MUST be in same transaction (but RLS is already enabled from migration 001, so we only need to swap policies atomically)
- Do NOT combine DROP CONSTRAINT + SET NOT NULL in single ALTER TABLE
- Use `DROP POLICY IF EXISTS` before creating to make idempotent
  </action>
  <verify>
Read all four migration files and verify:
1. Each file has clear header comments explaining purpose
2. Migration 002 creates profiles with all columns, indexes, RLS, trigger
3. Migration 003 adds nullable profile_id with NOT VALID FK and indexes to 3 tables
4. Migration 004 creates default profiles, backfills, and verifies
5. Migration 005 validates FKs, enforces NOT NULL, swaps RLS policies in transaction
6. All policies use (SELECT auth.uid()) wrapper
7. Service role bypass policies preserved on all tables
  </verify>
  <done>Four SQL migration files exist in supabase/migrations/ numbered 002-005, each idempotent and following the zero-downtime patterns from research.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Apply migrations to Supabase and verify</name>
  <what-built>
Four SQL migration files that establish profile-based data isolation:
- 002: profiles table with RLS
- 003: profile_id columns on projects/jobs/api_costs
- 004: default profile creation + data backfill
- 005: NOT NULL enforcement + profile-aware RLS policies

These must be applied IN ORDER to the live Supabase database.
  </what-built>
  <how-to-verify>
Apply each migration sequentially in Supabase Dashboard > SQL Editor:

1. Open Supabase Dashboard > SQL Editor
2. Paste and run `002_create_profiles_table.sql` - should succeed with no errors
3. Paste and run `003_add_profile_id_to_tables.sql` - should succeed
4. Paste and run `004_backfill_default_profiles.sql` - should succeed and print "Backfill verification passed"
5. Paste and run `005_enforce_constraints_and_rls.sql` - should succeed and print "Migration 005 verification passed"

After all migrations, verify in SQL Editor:
```sql
-- Check profiles table exists with data
SELECT * FROM profiles;

-- Check profile_id populated on projects
SELECT id, name, profile_id FROM editai_projects LIMIT 5;

-- Check RLS policies updated
SELECT tablename, policyname FROM pg_policies
WHERE schemaname = 'public'
ORDER BY tablename, policyname;

-- Check indexes exist
SELECT indexname FROM pg_indexes
WHERE schemaname = 'public' AND indexname LIKE 'idx_%profile%';

-- Performance check: should show Index Scan, not Seq Scan
EXPLAIN ANALYZE SELECT * FROM editai_projects
WHERE profile_id = (SELECT id FROM profiles LIMIT 1);
```
  </how-to-verify>
  <resume-signal>Type "applied" after running all four migrations successfully, or describe any errors encountered.</resume-signal>
</task>

</tasks>

<verification>
After both tasks complete:
1. `SELECT COUNT(*) FROM profiles WHERE is_default = true` returns >= 1
2. `SELECT COUNT(*) FROM editai_projects WHERE profile_id IS NULL` returns 0 (for rows with user_id)
3. `SELECT policyname FROM pg_policies WHERE tablename = 'editai_projects'` shows profile-aware policy names
4. `EXPLAIN ANALYZE` on profile_id filtered query shows Index Scan
5. Existing application still works (backend uses service role which bypasses RLS)
</verification>

<success_criteria>
- Profiles table exists with correct schema, RLS, and indexes
- All editai_projects rows have profile_id pointing to a valid default profile
- RLS policies filter by profile_id (through profiles.user_id) not just user_id directly
- Indexes on profile_id columns confirmed via pg_indexes
- Existing app functionality unaffected (service role bypass preserved)
</success_criteria>

<output>
After completion, create `.planning/phases/01-database-foundation/01-01-SUMMARY.md`
</output>
