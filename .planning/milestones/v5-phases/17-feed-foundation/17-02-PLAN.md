---
phase: 17-feed-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - app/services/image_fetcher.py
  - app/services/textfile_helper.py
autonomous: true
requirements:
  - COMP-05

must_haves:
  truths:
    - "Product images download in parallel with httpx async + Semaphore(5) concurrency cap"
    - "Failed image downloads produce a gray placeholder JPEG via FFmpeg lavfi instead of crashing"
    - "Downloaded images are cached on disk — re-running download for same product skips existing files"
    - "Romanian product names with diacritics (ă î ș ț â) render correctly in FFmpeg drawtext using textfile= pattern"
    - "textfile_helper creates temp UTF-8 files and returns the drawtext filter string — caller never uses text= for product content"
  artifacts:
    - path: "app/services/image_fetcher.py"
      provides: "Parallel image download with placeholder fallback"
      exports: ["download_product_images"]
    - path: "app/services/textfile_helper.py"
      provides: "FFmpeg textfile= pattern for Romanian diacritics"
      exports: ["build_drawtext_filter"]
  key_links:
    - from: "app/services/image_fetcher.py"
      to: "output/product_images/{feed_id}/"
      via: "httpx async download to disk cache"
      pattern: "product_images"
    - from: "app/services/textfile_helper.py"
      to: "FFmpeg drawtext filter"
      via: "textfile= temp file reference"
      pattern: "textfile="
---

<objective>
Build the image download pipeline and establish the FFmpeg textfile= pattern for Romanian diacritics — two independent utilities needed by all downstream video composition phases.

Purpose: Phase 18 (video compositor) needs local product images and the textfile= helper to render text overlays. Both must work reliably before any video generation code is written.
Output: image_fetcher.py (parallel downloads + placeholder), textfile_helper.py (drawtext filter builder), verified end-to-end with Romanian text.
</objective>

<execution_context>
@/home/ukfdb/.claude/get-shit-done/workflows/execute-plan.md
@/home/ukfdb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-feed-foundation/17-RESEARCH.md
@app/config.py (reference for settings.output_dir)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Parallel image downloader with placeholder fallback</name>
  <files>app/services/image_fetcher.py</files>
  <action>
Create `app/services/image_fetcher.py` with:

1. **Constants:**
   - `CONCURRENT_DOWNLOADS = 5`
   - `DOWNLOAD_TIMEOUT = httpx.Timeout(10.0, connect=3.0)` (aggressive — don't hang on slow CDNs)

2. **`async def download_product_images(products: list[dict], cache_dir: Path, feed_id: str) -> dict[str, str]`:**
   - Create `cache_dir` with `mkdir(parents=True, exist_ok=True)`
   - Create `asyncio.Semaphore(CONCURRENT_DOWNLOADS)`
   - For each product, create an async task `_download_one(product, cache_dir, semaphore)`
   - Use `asyncio.gather(*tasks)` to run in parallel
   - Return dict mapping `external_id -> local_file_path`

3. **`async def _download_one(product: dict, cache_dir: Path, semaphore: asyncio.Semaphore) -> tuple[str, str]`:**
   - `external_id = product['external_id']`
   - `dest = cache_dir / f"{external_id}.jpg"`
   - If `dest.exists()`: return early (cache hit)
   - If no `image_link`: return `_make_placeholder(dest)`
   - `async with semaphore:` download with `httpx.AsyncClient(follow_redirects=True, timeout=DOWNLOAD_TIMEOUT)`
   - Set headers: `{'User-Agent': 'Mozilla/5.0 (compatible; EditFactory/1.0)'}`
   - On success: write bytes to dest, return path
   - On ANY exception (timeout, 4xx, 5xx, connection error): log warning, return `_make_placeholder(dest)`
   - **WEBP handling:** If response content-type is `image/webp`, save as `.webp` then run FFmpeg to convert to `.jpg` (`ffmpeg -y -i input.webp output.jpg`). Delete the .webp after conversion.

4. **`def _make_placeholder(dest: Path) -> str`:**
   - Use FFmpeg lavfi to generate a 400x400 gray image with "No Image" text centered
   - Command: `ffmpeg -y -f lavfi -i color=c=808080:s=400x400 -vf "drawtext=text='No Image':fontsize=24:fontcolor=white:x=(w-text_w)/2:y=(h-text_h)/2" -vframes 1 {dest}`
   - Run with `subprocess.run(cmd, capture_output=True)`
   - Return `str(dest)`

5. **`def update_local_image_paths(supabase, image_map: dict[str, str], feed_id: str)`:**
   - For each external_id, local_path pair: update `products` table set `local_image_path = local_path` where `feed_id = feed_id AND external_id = external_id`
   - Batch into chunks of 100 to avoid excessive DB calls (use individual updates — supabase-py doesn't support batch UPDATE, but 100 sequential updates for 10k products takes ~10s which is acceptable in a background task)

Add logging using `import logging; logger = logging.getLogger(__name__)` — log download errors at WARNING level, cache hits at DEBUG.
  </action>
  <verify>
Import succeeds: `python -c "from app.services.image_fetcher import download_product_images, _make_placeholder; print('OK')"`.
Placeholder generation works: `python -c "from pathlib import Path; from app.services.image_fetcher import _make_placeholder; p = _make_placeholder(Path('/tmp/test_placeholder.jpg')); print(f'Created: {p}'); import os; assert os.path.exists(p); os.unlink(p); print('OK')"`.
  </verify>
  <done>image_fetcher.py provides download_product_images (async, parallel with Semaphore(5), cache-aware, placeholder fallback) and update_local_image_paths (DB update after download). Placeholder generation uses FFmpeg lavfi. All imports resolve.</done>
</task>

<task type="auto">
  <name>Task 2: FFmpeg textfile= helper for Romanian diacritics + end-to-end verification</name>
  <files>app/services/textfile_helper.py</files>
  <action>
Create `app/services/textfile_helper.py` with:

1. **`def build_drawtext_filter(text: str, fontsize: int = 36, fontcolor: str = 'white', x: str = '10', y: str = '10', fontfile: str = None, box: bool = False, boxcolor: str = 'black@0.5', boxborderw: int = 5) -> tuple[str, str]`:**
   - Write `text` to a temporary UTF-8 file using `tempfile.NamedTemporaryFile(mode='w', encoding='utf-8', suffix='.txt', delete=False)`
   - Build drawtext filter string: `drawtext=textfile='{tmp_path}':fontsize={fontsize}:fontcolor={fontcolor}:x={x}:y={y}`
   - If `fontfile` provided, add `:fontfile='{fontfile}'`
   - If `box=True`, add `:box=1:boxcolor={boxcolor}:boxborderw={boxborderw}`
   - Return tuple: `(filter_string, textfile_path)`
   - **IMPORTANT:** Caller is responsible for deleting textfile_path after FFmpeg completes (document in docstring)

2. **`def cleanup_textfiles(*paths: str)`:**
   - Delete each path with `os.unlink(path)`, swallowing FileNotFoundError
   - Convenience function for callers managing multiple drawtext filters

3. **`def build_multi_drawtext(texts: list[dict]) -> tuple[str, list[str]]`:**
   - Accept list of dicts, each with keys: `text`, `fontsize`, `fontcolor`, `x`, `y`, plus optional `fontfile`, `box`, `boxcolor`, `boxborderw`
   - Call `build_drawtext_filter` for each, collect filter strings and temp file paths
   - Join filter strings with `,` (FFmpeg filter chain separator)
   - Return `(combined_filter_string, list_of_textfile_paths)`
   - This enables product name + price + brand as a single `-vf` argument

**End-to-end verification script** (run as part of verify step, not saved as a file):
- Generate a 1-second black video with Romanian text "Preț special: Șoșete bărbați — 149,99 RON" using `build_drawtext_filter`
- Run FFmpeg with the generated filter string
- Assert FFmpeg returns exit code 0
- Clean up temp files and output video

This establishes the pattern that Phase 18 (product_video_compositor.py) will use for ALL text overlays — never use `text=` directly.
  </action>
  <verify>
Import succeeds: `python -c "from app.services.textfile_helper import build_drawtext_filter, cleanup_textfiles, build_multi_drawtext; print('OK')"`.
End-to-end Romanian test:
```bash
python -c "
from app.services.textfile_helper import build_drawtext_filter, cleanup_textfiles
import subprocess, os
filt, tmp = build_drawtext_filter('Preț special: Șoșete bărbați — 149,99 RON', fontsize=24, fontcolor='white')
cmd = ['ffmpeg', '-y', '-f', 'lavfi', '-i', 'color=c=black:s=640x360:d=1', '-vf', filt, '-t', '1', '-c:v', 'libx264', '/tmp/romanian_test.mp4']
result = subprocess.run(cmd, capture_output=True)
assert result.returncode == 0, f'FFmpeg failed: {result.stderr.decode()}'
cleanup_textfiles(tmp)
os.unlink('/tmp/romanian_test.mp4')
print('Romanian diacritics E2E: PASS')
"
```
  </verify>
  <done>textfile_helper.py provides build_drawtext_filter (single overlay), build_multi_drawtext (multiple overlays), and cleanup_textfiles. Romanian diacritics (ă î ș ț â Ș Ț) render correctly in FFmpeg drawtext via textfile= pattern. End-to-end verified with FFmpeg producing valid video output.</done>
</task>

</tasks>

<verification>
1. `from app.services.image_fetcher import download_product_images` — no import error
2. `from app.services.textfile_helper import build_drawtext_filter` — no import error
3. Placeholder generation produces a valid JPEG file at the specified path
4. FFmpeg textfile= with Romanian "Preț special: Șoșete bărbați — 149,99 RON" produces video (exit code 0)
5. Image cache directory structure: `output/product_images/{feed_id}/{external_id}.jpg`
6. build_multi_drawtext combines multiple drawtext filters into one -vf string
</verification>

<success_criteria>
- Image downloader handles parallel async downloads with concurrency cap
- Failed downloads produce placeholder (no crash, no missing file)
- Cache hits skip re-download
- Romanian diacritics render correctly in FFmpeg output video
- textfile= pattern established as THE way to do drawtext for product content
- All functions importable and tested
</success_criteria>

<output>
After completion, create `.planning/phases/17-feed-foundation/17-02-SUMMARY.md`
</output>
